{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"ISIS1225/","title":"academy/202520/ISIS1225 #UAndes #class","text":""},{"location":"ISIS1225/#isis1225","title":"ISIS1225","text":""},{"location":"ISIS1225/#cronograma","title":"Cronograma","text":"<pre><code>not done\nsort by priority\nsort by tag\nshort mode\ngroup by due\ntags includes #academy/202520/ISIS1225   \n</code></pre>"},{"location":"ISIS1225/#examenes","title":"Ex\u00e1menes","text":"<ul> <li>[ ] #academy/202520/ISIS1225 EVA1 \u23eb \ud83d\udcc5 2025-09-04 </li> <li>[ ] #academy/202520/ISIS1225 EVA2 \u23eb \ud83d\udcc5 2025-10-09 </li> <li>[ ] #academy/202520/ISIS1225 EVA3 \u23eb \ud83d\udcc5 2025-11-06 </li> <li>[ ] #academy/202520/ISIS1225 EVA4 \u23eb \ud83d\udcc5 2025-12-01 </li> </ul>"},{"location":"ISIS1225/#retos","title":"Retos","text":"<ul> <li>[ ] #academy/202520/ISIS1225 Reto1 release \ud83d\udcc5 2025-08-19</li> <li>[ ] #academy/202520/ISIS1225 Reto2 release \ud83d\udcc5 2025-09-15</li> <li>[ ] #academy/202520/ISIS1225 Reto3 release \ud83d\udcc5 2025-10-16</li> <li>[ ] #academy/202520/ISIS1225 Reto4 release \ud83d\udcc5 2025-11-11</li> <li>[ ] #academy/202520/ISIS1225 Reto1 entrega \ud83d\udd3c \ud83d\udcc5 2025-09-10</li> <li>[ ] #academy/202520/ISIS1225 Reto2 entrega\ud83d\udd3c \ud83d\udcc5 2025-10-15</li> <li>[ ] #academy/202520/ISIS1225 Reto3 entrega\ud83d\udd3c \ud83d\udcc5 2025-11-12 </li> <li>[ ] #academy/202520/ISIS1225 Reto4 entrega\ud83d\udd3c \ud83d\udcc5 2025-12-03 </li> </ul>"},{"location":"ISIS1225/#laboratorios","title":"Laboratorios","text":"<ul> <li>[x] #academy/202520/ISIS1225 LAB1 release \ud83d\udcc5 2025-08-07 \u2705 2025-08-07</li> <li> <p>[x] #academy/202520/ISIS1225 LAB1 entrega \ud83d\udcc5 2025-08-15 \u2705 2025-08-14</p> </li> <li> <p>[x] #academy/202520/ISIS1225 LAB2 release \ud83d\udcc5 2025-08-14 \u2705 2025-08-14</p> </li> <li> <p>[ ] #academy/202520/ISIS1225 LAB2 entrega \ud83d\udcc5 2025-08-20</p> </li> <li> <p>[ ] #academy/202520/ISIS1225 LAB3 release \ud83d\udcc5 2025-08-21  </p> </li> <li> <p>[ ] #academy/202520/ISIS1225 LAB3 entrega \ud83d\udcc5 2025-08-27</p> </li> <li> <p>[ ] #academy/202520/ISIS1225 LAB4 release \ud83d\udcc5 2025-08-28  </p> </li> <li> <p>[ ] #academy/202520/ISIS1225 LAB4 entrega \ud83d\udcc5 2025-09-03</p> </li> <li> <p>[ ] #academy/202520/ISIS1225 LAB5 parte 1 release \ud83d\udcc5 2025-09-11  </p> </li> <li> <p>[ ] #academy/202520/ISIS1225 LAB5 parte 1 entrega \ud83d\udcc5 2025-09-17</p> </li> <li> <p>[ ] #academy/202520/ISIS1225 LAB5 parte 2 release \ud83d\udcc5 2025-09-18  </p> </li> <li> <p>[ ] #academy/202520/ISIS1225 LAB5 parte 2 entrega \ud83d\udcc5 2025-09-24</p> </li> <li> <p>[ ] #academy/202520/ISIS1225 LAB6 release \ud83d\udcc5 2025-09-25  </p> </li> <li> <p>[ ] #academy/202520/ISIS1225 LAB6 entrega \ud83d\udcc5 2025-10-01</p> </li> <li> <p>[ ] #academy/202520/ISIS1225 LAB7 release \ud83d\udcc5 2025-10-16  </p> </li> <li> <p>[ ] #academy/202520/ISIS1225 LAB7 entrega \ud83d\udcc5 2025-10-22</p> </li> <li> <p>[ ] #academy/202520/ISIS1225 LAB8 release \ud83d\udcc5 2025-10-23  </p> </li> <li> <p>[ ] #academy/202520/ISIS1225 LAB8 entrega \ud83d\udcc5 2025-10-29</p> </li> <li> <p>[ ] #academy/202520/ISIS1225 LAB9 release \ud83d\udcc5 2025-10-30  </p> </li> <li> <p>[ ] #academy/202520/ISIS1225 LAB9 entrega \ud83d\udcc5 2025-11-05</p> </li> <li> <p>[ ] #academy/202520/ISIS1225 LAB10 parte 1 release \ud83d\udcc5 2025-11-13  </p> </li> <li> <p>[ ] #academy/202520/ISIS1225 LAB10 parte 1 entrega \ud83d\udcc5 2025-11-19</p> </li> <li> <p>[ ] #academy/202520/ISIS1225 LAB10 parte 2 release \ud83d\udcc5 2025-11-20  </p> </li> <li>[ ] #academy/202520/ISIS1225 LAB10 parte 2 entrega \ud83d\udcc5 2025-11-26</li> </ul>"},{"location":"ISIS1225/#w01m1","title":"W01M1","text":"<ul> <li>La idea del curso es organizar datos</li> <li>Cumplir restricciones y crit. de calidad<ul> <li>Tiempo</li> <li>Espacio</li> </ul> </li> <li>Los datos se pueden organizar en<ul> <li>Listas</li> <li>Pilas</li> <li>Colas</li> </ul> </li> <li>Y las estructuras son <ul> <li>Arboles</li> <li>Tablas (Hash)</li> <li>Grafos</li> </ul> </li> </ul>"},{"location":"ISIS1225/#arquitectura-de-aplicacion","title":"Arquitectura de aplicaci\u00f3n","text":"<ul> <li>Se divide en dos<ul> <li>La ==vista==, parte necesario para que el usuario haga uso de la aplicaci\u00f3n</li> <li>La ==l\u00f3gica==, realiza las op. sobre los datos y NO DEPENDE DE LA VISTA <p>[!note] La l\u00f3gica es as\u00ed \"Vista &lt;= L\u00f3gica &lt;= Modelos &lt;= Datos\"</p> </li> </ul> </li> </ul>"},{"location":"ISIS1225/#uso-de-git","title":"Uso de GIT","text":"<ul> <li>Tendremos tres estados<ul> <li>modified</li> <li>staged</li> <li>committed</li> </ul> </li> </ul>"},{"location":"ISIS1225/#algoritmos-y-complejidad","title":"Algoritmos y complejidad","text":"<p>Caracter\u00edsticas: - Precisos - Correctos  - Determin\u00edsticos - Finito Cualidades: - General - Eficiente Siendo as\u00ed separamos el an\u00e1lisis de algoritmos en dos categor\u00edas importantes, temporal y espacial.</p>"},{"location":"ISIS1225/#w01m2","title":"W01M2","text":"<ul> <li>El algoritmo de busqueda binar\u00eda es un ejemplo de un algoritmo m\u00e1s eficiente que otro en otra tarea... \u00bfPero porque?</li> </ul>"},{"location":"ISIS1225/#tiempo-de-ejecuciion","title":"Tiempo de ejecuci\u00edon","text":"<ul> <li>No todos los algoritmos vana  ser iguales, y vamos a ver que estos tienen una complejidad que involucra el espacio en memoria que ocupan y el tiempo que tardan en cumplir su tarea.</li> <li> </li> <li> <p>No depende del hardware ni de la ejecuci\u00f3n.</p> </li> <li> <p>Usa y considera todos los datos.</p> </li> <li> <p>Tres notaciones principales:</p> <ul> <li> <p>Big Theta (\u0398): Crecimiento pr\u00e1cticamente igual en todos los casos.</p> </li> <li> <p>Big Omega (\u03a9): Crecimiento m\u00ednimo garantizado (mejor caso).</p> </li> <li> <p>Big O (O): Crecimiento m\u00e1ximo (peor caso).</p> </li> </ul> </li> </ul> <p>7 \u00f3rdenes de crecimiento temporal t\u00edpicos</p> <ol> <li> <p>O(1) \u2013 Constante:</p> <ul> <li> <p>Tiempo no depende del tama\u00f1o de los datos.</p> </li> <li> <p>Ejemplo: <code>len(lista)</code>, comparaciones, m\u00f3dulo.</p> </li> <li> <p>Todas las operaciones primitivas son constantes.</p> </li> </ul> </li> <li> <p>O(n) \u2013 Lineal:</p> <ul> <li> <p>Tiempo crece proporcionalmente con la cantidad de datos.</p> </li> <li> <p>Ejemplo: recorrer una lista una vez.</p> </li> <li> <p>Big O suele considerar el peor caso.</p> </li> </ul> </li> <li> <p>O(log n) \u2013 Logar\u00edtmico:</p> <ul> <li> <p>Crecimiento lento del tiempo con respecto al tama\u00f1o.</p> </li> <li> <p>Aparece en divisiones sucesivas y algoritmos tipo b\u00fasqueda binaria.</p> </li> </ul> </li> <li> <p>O(n log n) \u2013 Lineal\u00edtmico:</p> <ul> <li>Ejemplo t\u00edpico: algoritmos de ordenamiento eficientes.</li> </ul> </li> <li> <p>O(n\u00b2) \u2013 Cuadr\u00e1tico</p> </li> <li> <p>O(n\u00b3) \u2013 C\u00fabico</p> </li> <li> <p>O(b\u207f) \u2013 Exponencial</p> </li> </ol>"},{"location":"ISIS1225/#aproximacion-a-priori","title":"Aproximaci\u00f3n a prior\u00ed","text":""},{"location":"ISIS1225/#w02m1","title":"W02M1","text":""},{"location":"ISIS1225/#aproximacion-empirica-a-posteriori","title":"Aproximaci\u00f3n (emp\u00edrica a posteriori)","text":"<p>Ventajas * Realista * Sencilla Desventajas * Depende del entorno     * Del hardware, S.O., programas concurrentes, etc.  * No se puede generalizar     * Informaci\u00f3n limitada a tama\u00f1os de entrada espec\u00edficos         * No aplica a todos los tama\u00f1os * Influencia de factores externos * Carga del sistema y gesti\u00f3n de memoria pueden distorsionar resultados.</p>"},{"location":"ISIS1225/#complejidad-espacial","title":"Complejidad Espacial","text":"<ul> <li>Mide la memoria usada por un algoritmo en relaci\u00f3n al tama\u00f1o de entrada</li> <li>Generalmente basado en el peor caso de uso de memoria</li> <li>Incluye la memoria usada por<ul> <li>Variables </li> <li>Asignaciones din\u00e1micas</li> <li>==Estructuras de datos==</li> </ul> </li> </ul>"},{"location":"ISIS1225/#espacio-constante-o1","title":"Espacio constante O(1)","text":"<ul> <li>El espacio no depende del tama\u00f1o de la entrada</li> </ul> <pre><code>def suma(num1, num2):\n    suma = num1 + num2\n    return suma\nprint(suma(2,2))\n</code></pre> <ul> <li>Es idenpendiente del tamao de <code>num1</code> y <code>num2</code><ul> <li>Solo necesita espacio constante para <code>suma</code></li> </ul> </li> </ul>"},{"location":"ISIS1225/#espacio-lineal-on","title":"Espacio lineal O(n)","text":"<ul> <li>El espacio crece linealmente con el tama\u00f1o de la entrada</li> </ul> <pre><code>lista = [1,2,3]\ndef duplicar_lista(lista):\n    lista_duplicada = []\n    for elemento in lista:\n        lista_duplicada.append(elemento * 2)\n    return lista_duplicada\nprint(duplicar_lista(lista))\n</code></pre> <ul> <li>El espacio necesario para <code>lista_duplicada</code> es igual al de la lista que estamos intentando duplicar, por lo tanto crece linealmente.</li> </ul>"},{"location":"ISIS1225/#espacio-auxiliar","title":"Espacio auxiliar","text":"<ul> <li>Memoria adicional aparte de la entrada</li> </ul> <pre><code>lista = [5,7,89,3,5]\ndef ordenar_lista(lista):\n    lista_ordenada = sorted(lista)\n    return lista_ordenada\nprint(ordenar_lista(lista))\n</code></pre> <ul> <li>La <code>lista_ordenada</code> es una copia de la lista<ul> <li>Resultado en un espacio adicional<ul> <li>Proporcional al tama\u00f1o de lista original</li> </ul> </li> </ul> </li> </ul> <p>[!question] No entiendo la diferencia entre espacio lineal O(n) y el espacio auxiliar</p> <p>Diferencia entre O(n) espacio y espacio auxiliar O(n) * Espacio total*: Toda la memoria que usa el algoritmo (entrada + salida + variables temporales). * Espacio auxiliar: Memoria extra* necesaria aparte de la entrada. *  | Caso | Entrada (<code>n</code>) | Memoria adicional | Espacio total | Espacio auxiliar | |------|---------------|------------------|---------------|------------------| | Duplicar lista | <code>n</code> | <code>n</code> | <code>O(n)</code> | <code>O(n)</code> | | Ordenar lista (copia) | <code>n</code> | <code>n</code> | <code>O(n)</code> | <code>O(n)</code> | | Ordenar in-place | <code>n</code> | constante | <code>O(n)</code> | <code>O(1)</code> |</p> <p>Conclusi\u00f3n:  - O(n) espacio: Memoria total crece proporcionalmente a <code>n</code>. - Espacio auxiliar O(n): Memoria extra (aparte de la entrada) crece proporcionalmente a <code>n</code>. - Un algoritmo puede tener espacio total O(n) pero auxiliar O(1) si modifica la entrada directamente.</p>"},{"location":"ISIS1225/#recursividad","title":"Recursividad","text":"<ul> <li>La funci\u00f3n se invoca a s\u00ed misma<ul> <li>Resuelve instancia m\u00e1s peque\u00f1a que el problema general</li> </ul> </li> <li>En ejemplo cl\u00e1sico son las mu\u00f1ecas rusas<ul> <li>Versiones m\u00e1s peque\u00f1as anidadas</li> <li>Profundidad finita</li> </ul> </li> <li>Como en [[MATE1102]] hay dos casos<ul> <li>Caso base<ul> <li>Condici\u00f3n que detiene la recursi\u00f3n</li> <li>La funci\u00f3n no se invoca a si misma</li> </ul> </li> <li>Caso recursivo<ul> <li>Funci\u00f3n que se invoca a s\u00ed misma</li> <li>Es una versi\u00f3n ==m\u00e1s peque\u00f1a== del problema</li> </ul> </li> </ul> </li> </ul>"},{"location":"ISIS1225/#metodologia-de-desarollo-de-sofware","title":"Metodolog\u00eda de desarollo de sofware","text":"<p>Aqu\u00ed el orden importa</p> <p>[!warning] An\u00e1lisis &gt; Dise\u00f1o &gt; Construcci\u00f3n &gt; Pruebas</p>"},{"location":"ISIS1225/#analisis","title":"An\u00e1lisis","text":"<ol> <li>Identificar y especificar el problema</li> <li>Identificar restrucciones</li> <li>Documentar</li> <li>La idea es planear desde antes que es lo que se va a realizar y que tiene que hacer la funci\u00f3n que vamos a realizar</li> <li>Hay que entender su proposito y adem\u00e1s que entradas y salidas vamos a esperar/dise\u00f1ar</li> <li> <p>Finalmente tambi\u00e9n es importante pensar en las restricciones del mismo y como estas van a afectar el dise\u00f1o. Estas aplican tanto para ==entrada como para salida==</p> </li> <li> <p>Una vez hemos hecho e identificado el profeso arriba ya podemos escribir la documentaci\u00f3n:</p> </li> </ol> <pre><code>\n\"\"\"\nCalcula el factorial de un n\u00famero (n!)\n\nparam numero: El n\u00famero positivo para calcular su factorial\n:type numero: int\n\n:returns: El factorial del n\u00famero proporcionado\n:rtype: int\n\"\"\"\n# Nota este de arriba es el formato de documentaci\u00f3n para EDA.\n\n</code></pre> <p>Note que la documentaci\u00f3n refleja claramente las restricciones y la naturaleza de la entrada/salida.</p>"},{"location":"ISIS1225/#diseno","title":"Dise\u00f1o","text":"<ol> <li>Formular ejemplo<ol> <li>Casos significativos y no redundantes</li> </ol> </li> <li>Dise\u00f1ar algoritmo</li> <li>Dise\u00f1ar y documentar las pruebas</li> </ol> <p><code>factorial (0) = 1 factorial (1) = 1 factorial (2) = 2 .... etc.</code></p>"},{"location":"ISIS1225/#repaso-bono-w02m1","title":"Repaso Bono W02M1","text":"<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\n# Valores de n\nn_values = np.arange(1, 20)\n\n# Crecimientos\nlinear = n_values\nquadratic = n_values**2\nnlogn = n_values * np.log2(n_values)\nexponential = 2**n_values\n\nplt.figure(figsize=(8,5))\nplt.plot(n_values, linear, label=r\"$n$\", marker='o')\nplt.plot(n_values, quadratic, label=r\"$n^2$\", marker='o')\nplt.plot(n_values, nlogn, label=r\"$n \\log n$\", marker='o')\nplt.plot(n_values, exponential, label=r\"$2^n$\", marker='o')\n\nplt.ylim(0, 200)  # limitar para ver las curvas m\u00e1s peque\u00f1as\nplt.xlabel(\"Tama\u00f1o de entrada n\")\nplt.ylabel(\"N\u00famero de operaciones (escala lineal)\")\nplt.title(\"Comparaci\u00f3n de \u00f3rdenes de crecimiento\")\nplt.legend()\nplt.grid(True)\nplt.show()\n\n</code></pre> <p>Aqu\u00ed ves c\u00f3mo crecen las funciones:</p> <ul> <li> <p>O(n) crece de forma lineal.</p> </li> <li> <p>O(n log n) crece un poco m\u00e1s r\u00e1pido, pero sigue siendo mucho menor que cuadr\u00e1tica para valores grandes.</p> </li> <li> <p>O(n\u00b2) crece muy r\u00e1pido.</p> </li> <li> <p>O(2\u207f) explota enseguida, incluso con n peque\u00f1o.</p> </li> </ul> <p>Esto es por lo que un algoritmo exponencial se vuelve impracticable muy r\u00e1pido.</p>"},{"location":"ISIS1225/#complejidad-temporal","title":"Complejidad temporal","text":"<pre><code>lista = [7,6,4,3,1,5,9]\nelemento_a_buscar = 5\ndef busqueda_secuencial(lista, elemento_a_buscar):\n    resultado = None\n    encontrado = False\n    indice = 0 \n    while indice &lt; len(lista) and not encontrado:\n        if lista[indice] == elemento_a_buscar:\n            resultado = lista[indice]  \n            encontrado = True\n        indice += 1 \n\n    return resultado\nprint(busqueda_secuencial(lista, elemento_a_buscar))\n</code></pre> <p>y ahora comparemoslo al algoritmo de busqueda binar\u00eda</p> <pre><code>lista = [1,2,3,4,5,6]\nelemento_a_buscar = 5\ndef busqueda_binaria(lista, elemento_a_buscar):\n    inicio, fin = 0, len(lista) - 1\n    resultado = None\n    encontrado = False\n    while inicio &lt;= fin and not encontrado:\n        medio = (inicio + fin)//2\n        if lista[medio] &lt; elemento_a_buscar:\n            inicio = medio  + 1\n        elif lista[medio] &gt; elemento_a_buscar:\n            inicio = medio  - 1\n        else:\n            resultado = lista[medio]\n            encontrado = True\n    return resultado\nprint(busqueda_binaria(lista, elemento_a_buscar))\n\n</code></pre> <ul> <li>Uno es mucho m\u00e1s r\u00e1pido que el otro, pero porque exactamente....</li> <li>Partimos del m\u00e9todo cient\u00edfico</li> </ul> <p>[!note] Complejidad temporal Tiempo total de ejecuci\u00f3n = N\u00famero de operaciones requeridas * Tiempo por operaci\u00f3n</p> <p>[!note] Complejidad espacial Memoria total = N\u00famero objetos requeridos * Memoria por objeto</p>"},{"location":"ISIS1225/#aproximacion-teorica-a-prori","title":"Aproximaci\u00f3n te\u00f3rica (a prori)","text":"<ul> <li>Determinaci\u00f3n aproximaci\u00f3n matem\u00e1tica</li> <li>Ventajas: No requiere la implementaci\u00f3n del algoritmo</li> <li>No depende del hardware o sofware de soporte<ul> <li>Independiente del tama\u00f1o de los datos de entrada</li> <li>Considera todos los datos de entrada</li> </ul> </li> </ul>"},{"location":"ISIS1225/#notaciones-para-la-complejidad-algoritmica","title":"Notaciones para la complejidad algoritmica","text":"<ol> <li>Big Theta $\\Theta$<ol> <li>Que es la que mide exactamente como se comporta el algoritmo en terminos de tiempo vs tama\u00f1o de datos (L\u00edmite asintotico de los datos)</li> <li>Poco usada porque es muy dificil de obtener</li> <li>Baja aplicabilidad</li> </ol> </li> <li>Big Omega $\\Omega$<ol> <li>Es b\u00e1sicamente el l\u00edmite inferior asint\u00f3tico </li> </ol> </li> <li>Big O $O$<ol> <li>Establece el l\u00edmite superior asint\u00f3tico</li> <li>Se usa para describir la complejidad m\u00e1xima de un algoritmo, y siempre va por arriba del estimado en la gr\u00e1fica de tiempo vs tama\u00f1o de los datos.</li> <li>Siempre estima por arriba. Es MUY INFORMATIVO.</li> </ol> </li> </ol>"},{"location":"ISIS1225/#orden-constante-o1","title":"Orden constante $O(1)$","text":"<pre><code>1.  Tiempo constante y predecible\n2. No aumenta con el tama\u00f1o de la entrada, osea indpendiente del tama\u00f1o de los datos\n</code></pre> <p>Ejemplos de operaciones primitivas o constantes: ![[Pasted image 20250811200137.png]]</p> <p>Ahora un ejemplo de algoritmo de orden constante</p> <pre><code>def es_par(n):\n    \"\"\"\n    Determina si un n\u00famero es par o impar.\n    Args:\n        n (int): el n\u00famero a verificar.\n    Returns:\n        bool: True si n es par, False si n es impar.\n    \"\"\"\n    return n % 2 == 0\nprint(es_par(5))\n</code></pre> <ul> <li>Note que realmente solo se esta usando funciones que tienen ordenes constantes $O(1)$</li> </ul> <p>Quiz1</p> <pre><code>lista = [1,2,3,4,5,6]\npos = 0\ndef dar_elemento_en_posicion(lista, pos):\n    \"\"\"\n    Retorna el elemento en la posici\u00f3n especificada de la lista.\n\n    Args:\n        lista (list): La lista de la cual obtener el elemento.\n        pos (int): La posici\u00f3n del elemento a retornar.\n\n    Returns:\n        El elemento en la posici\u00f3n dada o None si la posici\u00f3n es inv\u00e1lida.\n    \"\"\"\n    resultado = None\n    if 0 &lt;= pos &lt; len(lista):\n        resultado = lista[pos]\n    return resultado\nprint(dar_elemento_en_posicion(lista, pos))\n</code></pre> <p>Este como vemos tiene una complejidad temporal de $O(1)$ porque solo se utilizan operaciones primitivas que se repiten una unica vez. No hay ciclos y no, if no es un ciclo. Todas son comparaciones. Y recuerde ==PRINT() NO ES $O(1)$==.</p>"},{"location":"ISIS1225/#orden-lineal-on","title":"Orden lineal $O(n)$","text":"<ul> <li>Caracter\u00edsticas<ul> <li>Tiempo crece proporcionalmente con la cantidad de datos</li> <li>T\u00edpicamente, cada elemento se procesa una vez</li> </ul> </li> <li>Ventajas<ul> <li>Simple de entender e interpretar</li> <li>Eficiente para vol\u00famenes de datos peque\u00f1os o medianos</li> </ul> </li> <li>Desventajas<ul> <li>Ineficiente a gran escala un ejemplo es:</li> </ul> </li> </ul> <pre><code>for elemento in lista:\n    # Expresiones O(1)\n</code></pre> <p>Es f\u00e1cil ver como el tiempo requerido para correrlo va a crecer de manera lineal con la cantidad de datos.</p> <pre><code>def sumar_elementos(lista):\n    '''\n    Suma todos los elementos de una lista.\n\n    Args:\n        arreglo (list): Una lista de n\u00fameros (int o float).\n\n    Returns:\n        int o float: La suma de todos los elementos en la lista.\n    '''\n    total = 0\n    for elemento in lista:\n        total += elemento\n    return total\n</code></pre> <p>De nuevo es lineal porque note que las operaciones $O(1)$ se estan repitiendo n veces, las n veces corresponden a los n elementos de la lista.</p> <pre><code>def sumar_elementos(lista):\n    total = 0\n    for elemento in lista:\n        total += elemento\n    return total\n</code></pre> <p>Otro ejemplo quee es lineal pues va a depender de que tantos elementos busquemos sumar, esta es una buena forma de verificar si el comportamiento que vemos es $O(1)$ o $O(n)$.</p> <p>Y acon que haya una sola operaci\u00f3n que se repita <code>n</code> veces es suficiente para que sea un orden lineal. }</p>"},{"location":"ISIS1225/#analisis-de-algoritmos-por-casos","title":"An\u00e1lisis de algoritmos por casos","text":"<ul> <li>El an\u00e1lisis de algoritmos no constantes, t\u00edpicamente considera tres casos:</li> <li>Peor caso:<ul> <li>Input que requiere el m\u00e1ximo tiempo de ejecuci\u00f3n del algoritmo</li> </ul> </li> <li>Mejor caso:<ul> <li>Input que requiere el m\u00ednimo tiempo de ejecuci\u00f3n del algoritmo</li> </ul> </li> <li>Caso promedio:<ul> <li>Estimaci\u00f3n promedio del tiempo de ejecuci\u00f3n<ul> <li>Considerando la distribuci\u00f3n probabil\u00edstica del input Por ejemplo:</li> </ul> </li> </ul> </li> </ul> <pre><code>for elemento in lista:\n    if elemento == valor_buscado:\n        # Valor encontrado\n        # Fin de b\u00fasqueda\n</code></pre> <p>En este caso, si el primer valor de la lista es el valor que buscamos vamos a obtener el mejor de los casos, osea un $O(1)$, pero lo m\u00e1s probable es que esto no sea verdad y que tengamos que repetir la igualdad del if por cada elemento (hay un for entonces repetimos la instrucci\u00f3n), esto quiere decir que vamos a terminar con un $O(n)$ en promedio y el peor de los casos no vamos a encontrar el dato pero si estamos revisando cada cosa entonces va a ser $O(n)$ tambi\u00e9n.</p> <p>[!tip] Recuerde que la notaci\u00f3n Bif $O$ usa siempre el peor caso</p> <p>Por ejemplo en el caso de la busqueda_secuencial encontramos que en efecto se trata de que no encontraremos el dato, y en notaci\u00f3n $O$, esto quiere decir que va a tener una complejidad $O(n)$.</p>"},{"location":"ISIS1225/#orden-logaritmico-olog-n","title":"Orden logar\u00edtmico O(log n)","text":"<ul> <li>Caracter\u00edsticas<ul> <li>Tiempo incrementa lentamente a medida que crecen los datos</li> </ul> </li> <li>Ventajas<ul> <li>Eficiente para grandes cantidades de datos</li> </ul> </li> <li>Desventajas<ul> <li>Mayor complejidad de implementaci\u00f3n</li> <li>Costos de ordenamiento y mantenimiento de datos</li> </ul> </li> </ul> <ul> <li>Caracter\u00edstica clave:<ul> <li>Reducci\u00f3n significativa y r\u00e1pida del rango de operaci\u00f3n</li> </ul> </li> <li>Explicaci\u00f3n:<ul> <li>Variable se <code>i</code> divide por <code>c</code> en cada iteraci\u00f3n<ul> <li>Disminuci\u00f3n hasta que <code>i &lt;= 1</code></li> </ul> </li> </ul> </li> <li>Iteraciones limitadas a logc de <code>n</code><ul> <li>En complejidad temporal, no importa el coeficiente constante de log<ul> <li>Entonces, la complejidad logar\u00edtmica es O(log n) Ejemplo:</li> </ul> </li> </ul> </li> </ul> <pre><code>i = n\nwhile i &gt; 0:\n    # Expresiones O(1)\n    i /= c  # \u00f3 divisi\u00f3n entera\n</code></pre> <pre><code>i = 1\nwhile i &lt; n:\n    # Expresiones O(1)\n    i *= c\n</code></pre> <p>Son b\u00e1sicamente expresiones O(1), pero note que hay una divisi\u00f3n o una exponencial que me va cortando las posibilidades hasta que el algoritmo termina de correr, as\u00ed b\u00e1sicamente aplicando la estrategia de divide y venceras.</p> <p>Recordemos entonces que la ==b\u00fasqueda binar\u00eda== va a tener este tipo e complejidad temporal.</p> <p>[!tldr] Caracter\u00edstica clave Itera reduciendo la b\u00fasqueda a la mitad en cada paso</p>"},{"location":"ISIS1225/#busqueda-secuencial-vs-busqueda-binaria-22","title":"B\u00fasqueda secuencial vs b\u00fasqueda binaria (2/2)","text":"<ul> <li> <p>B\u00fasqueda secuencial:</p> <ul> <li>Orden lineal O(n):<ul> <li>Simple pero ineficiente para grandes cantidades de datos</li> </ul> </li> <li> <p>B\u00fasqueda binaria:</p> </li> <li> <p>Orden logar\u00edtmico O(log n):</p> <ul> <li>M\u00e1s complejo y requiere ordenamiento, pero,<ul> <li>Muy eficiente para grandes cantidades de datos</li> </ul> </li> </ul> </li> </ul> </li> </ul> <pre><code>for i in range(1, n):  # Parte lineal\n    # Expresiones O(1)\n    j = 1\n    while j &lt; n:  # Parte logar\u00edtmica\n        # Expresiones O(1)\n        j *= 2\n</code></pre> <p>Otro ejemplo un poco m\u00e1s elaborado:</p> <pre><code>def buscar_en_sublistas_con_bbinaria(listas, elemento_buscado):\n    \"\"\"\n    Busca un elemento en cada sublista ordenada de la lista principal.\n\n    Args:\n        listas (list of list): Lista de sublistas ordenadas.\n        elemento_buscado: el elemento a buscar.\n\n    Returns:\n        tuple: (\u00edndice_lista_principal, \u00edndice_sublista) del elemento\n        encontrado, o (None, None) si el elemento no se encuentra.\n    \"\"\"\n    resultado = (None, None)\n    encontrado = False\n\n    for indice_lista_principal, sublista in enumerate(listas):\n        if not encontrado:\n            indice_sublista = busqueda_binaria(sublista, elemento_buscado)\n            if indice_sublista is not None:\n                resultado = (indice_lista_principal, indice_sublista)\n                encontrado = True\n    return resultado\n</code></pre> <p>Note que b\u00e1sicamente se esta haciendo una busqueda lineal, la cual ya sabemos que tiene una complejidad temporal de O(n), y dentro de esta se esta buscando las sublistas mediante el m\u00e9todo de busqueda binaria, que es O(log n), lo cual resulta en una complejidad espacial O(n log m)</p>"},{"location":"ISIS1225/#orden-linearitmico-on-logn","title":"Orden linear\u00edtmico O(n log(n))","text":"<ul> <li>Caracter\u00edsticas</li> <li>Combinaci\u00f3n de lineal y logar\u00edtmico:<ul> <li>Tiempo crece proporcional a n y a n log n</li> </ul> </li> <li>M\u00e1s r\u00e1pido que lineal para grandes n, pero m\u00e1s lento que logar\u00edtmico</li> <li>Ventajas</li> <li>Eficiente de moderadas a grandes vol\u00famenes de datos</li> <li>Desventajas</li> <li>Mayor complejidad de implementaci\u00f3n</li> <li>M\u00e1s lento que algoritmos logar\u00edtmicos puros</li> <li>Puede ser muy costoso para algunos vol\u00famenes de datos grandes Ejemplo:</li> </ul>"},{"location":"ISIS1225/#orden-cuadratico-on2","title":"Orden cuadr\u00e1tico O(n2)","text":"<ul> <li> <p>Caracter\u00edsticas</p> <ul> <li> <p>El tiempo de ejecuci\u00f3n escala con el cuadrado del tama\u00f1o de la entrada</p> </li> <li> <p>Tiempo proporcional a n\u00b2</p> </li> <li> <p>Efectivo para peque\u00f1as entradas,</p> <ul> <li>Pero impr\u00e1ctico r\u00e1pidamente con grandes vol\u00famenes</li> <li>Ventajas</li> </ul> </li> <li> <p>Simple de entender e interpretar</p> </li> <li> <p>Eficiente para conjuntos de datos muy peque\u00f1os, con operaciones espec\u00edficas</p> </li> </ul> </li> <li> <p>Desventajas</p> <ul> <li>Ineficiente para grandes vol\u00famenes de datos Ejemplo:</li> </ul> </li> </ul> <pre><code>for i in range(n):\n    for j in range(n):\n        # Expresiones O(1)\n</code></pre> <p>El hecho de tener dos loops anidados, o dos cosas que dependen de n autom\u00e1ticamente lo hace $O(n^2)$</p>"},{"location":"ISIS1225/#complejidad-temporal-shaker-sort-13","title":"Complejidad temporal - Shaker Sort (1/3)","text":"<p>Estime el orden de crecimiento temporal del siguiente algoritmo:</p> <pre><code>def cocktail_shaker_sort(arr: list[int]) -&gt; None:\n    start = 0\n    end = len(arr) - 1\n    swapped = True\n\n    while swapped:\n        swapped = False\n        # Movimiento de izquierda a derecha\n        for i in range(start, end):\n            if arr[i] &gt; arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                swapped = True\n        end -= 1\n\n        # Movimiento de derecha a izquierda\n        for i in range(end, start, -1):\n            if arr[i] &lt; arr[i - 1]:\n                arr[i], arr[i - 1] = arr[i - 1], arr[i]\n                swapped = True\n        start += 1\n</code></pre> <p>[!warning] Ojo el Shaker sort SI ES $O(n^2)$</p>"},{"location":"ISIS1225/#orden-cubico-on3","title":"Orden c\u00fabico O(n\u00b3)","text":"<ul> <li> <p>Caracter\u00edsticas</p> <ul> <li>Tiempo de ejecuci\u00f3n proporcional al cubo del tama\u00f1o de la entrada</li> <li>Efectivo para peque\u00f1as entradas<ul> <li>Pero impr\u00e1ctico r\u00e1pidamente con grandes vol\u00famenes</li> </ul> </li> <li> <p>Ventajas</p> </li> <li> <p>Puede ser adecuado para problemas</p> <ul> <li>Que requieren operaciones tridimensionales</li> </ul> </li> <li> <p>Desventajas</p> </li> <li> <p>Muy ineficiente a medida que el tama\u00f1o de la entrada crece</p> </li> </ul> </li> </ul> <pre><code>for i in range(n):\n    for j in range(n):\n        for k in range(n):\n            # Expresiones O(1)\n</code></pre> <pre><code>def buscar_tripletes(lista):\n    \"\"\"\n    Encuentra todos los tripletes que sumen cero.\n\n    Args:\n        lista (list): lista de n\u00fameros enteros.\n\n    Returns:\n        list of tuples: lista de tripletes (i, j, k), donde i + j + k == 0.\n    \"\"\"\n    triplete = []\n    for i in lista: # Se ejecuta n veces\n        for j in lista: # Se ejecuta n veces, por cada iteraci\u00f3n de i\n            for k in lista: # Se ejecuta n veces, por cada iteraci\u00f3n de j\n                if i + j + k == 0: # Se ejecuta n * n * n\n                    triplete.append((i, j, k)) # Se ejecuta hasta n * n * n\n    return triplete\n</code></pre>"},{"location":"ISIS1225/#orden-exponencial-obn","title":"Orden exponencial O(b\u207f)","text":"<ul> <li> <p>Caracter\u00edsticas</p> <ul> <li> <p>Crecimiento muy r\u00e1pido</p> <ul> <li>El tiempo aumenta exponencialmente con el tama\u00f1o de la entrada</li> <li>Tiempo proporcional a <code>b\u207f</code>, donde <code>b</code> y <code>n</code> son <code>&gt; 1</code><ul> <li>T\u00edpicamente involucra algoritmos que exploran todas las posibilidades</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Ventajas</p> <ul> <li>Apropiado para problemas peque\u00f1os donde se requieren soluciones exhaustivas</li> <li> <p>Desventajas</p> </li> <li> <p>Generalmente no es viable para grandes vol\u00famenes de datos</p> </li> </ul> </li> </ul> <pre><code>def generar_combinaciones(conjunto):\n    \"\"\"\n    Genera todas las combinaciones posibles de un conjunto.\n\n    Args:\n        conjunto: Lista que representa el conjunto (Ej.:, [\"A\", \"B\", \"C\"])\n\n    Retrurns:\n        list of lists: Todas las combinaciones posibles\n    \"\"\"\n    n = len(conjunto)\n    total_combinaciones = 2 ** n  # N\u00famero total de combinaciones\n    combinaciones = []\n\n    for i in range(total_combinaciones):\n        combinacion_actual = []\n        for j in range(n):\n            # Verifica si el bit j est\u00e1 encendido en el n\u00famero i:\n            if i &amp; (1 &lt;&lt; j):   \n                combinacion_actual.append(conjunto[j])\n        combinaciones.append(combinacion_actual)\n    return combinaciones\n</code></pre>"},{"location":"ISIS1225/#aproximacion-empirica-a-posteriori-33","title":"Aproximaci\u00f3n emp\u00edrica (a posteriori ) (3/3)","text":"<pre><code>import time  \n\nstart_time = time.time()  \n\n# Your code or operation to be timed goes here  \n# Example:  \nsum(range(10**2))  \n\nend_time = time.time()  \nelapsed_time = end_time - start_time  \n\nprint(f\"Elapsed time: {elapsed_time:.4f} seconds\")\n</code></pre> <ul> <li> <p>\"Realismo\"\u00a0</p> <ul> <li>Mide comportamiento directo\u00a0<ul> <li>Considerando constantes y algunos factores secundarios</li> </ul> </li> <li> <p>\"Sencillez\"\u00a0</p> </li> <li> <p>Puede\u00a0 ser m\u00e1s f\u00e1cil de implementar que algunos an\u00e1lisis te\u00f3ricos</p> <ul> <li>Especialmente en algoritmos complejos</li> </ul> </li> </ul> </li> </ul> <pre><code>def suma(num1, num2):\n    suma = num1 + num2\n    return suma\nprint(suma(2,2))\n</code></pre> <ul> <li>Es idenpendiente del tamao de <code>num1</code> y <code>num2</code><ul> <li>Solo necesita espacio constante para <code>suma</code></li> </ul> </li> </ul>"},{"location":"ISIS1225/#complejidad-espacial_1","title":"Complejidad Espacial","text":"<ul> <li>Mide la memoria usada por un algoritmo en relaci\u00f3n al tama\u00f1o de entrada</li> <li>Generalmente basado en el peor caso de uso de memoria</li> <li>Incluye la memoria usada por</li> <li>Variables </li> <li>Asignaciones din\u00e1micas</li> <li>==Estructuras de datos==</li> </ul>"},{"location":"ISIS1225/#espacio-constante-o1_1","title":"Espacio constante O(1)","text":"<ul> <li>El espacio no depende del tama\u00f1o de la entrada</li> </ul>"},{"location":"ISIS1225/#espacio-lineal-on_1","title":"Espacio lineal O(n)","text":"<ul> <li>El espacio crece linealmente con el tama\u00f1o de la entrada</li> </ul> <pre><code>lista = [1,2,3]\ndef duplicar_lista(lista):\n    lista_duplicada = []\n    for elemento in lista:\n        lista_duplicada.append(elemento * 2)\n    return lista_duplicada\nprint(duplicar_lista(lista))\n</code></pre> <ul> <li>El espacio necesario para <code>lista_duplicada</code> es igual al de la lista que estamos intentando duplicar, por lo tanto crece linealmente.</li> </ul>"},{"location":"ISIS1225/#espacio-auxiliar_1","title":"Espacio auxiliar","text":"<ul> <li>Memoria adicional aparte de la entrada</li> </ul> <pre><code>lista = [5,7,89,3,5]\ndef ordenar_lista(lista):\n    lista_ordenada = sorted(lista)\n    return lista_ordenada\nprint(ordenar_lista(lista))\n</code></pre> <ul> <li>La <code>lista_ordenada</code> es una copia de la lista<ul> <li>Resultado en un espacio adicional<ul> <li>Proporcional al tama\u00f1o de lista original</li> </ul> </li> </ul> </li> </ul> <p>[!question] No entiendo la diferencia entre espacio lineal O(n) y el espacio auxiliar</p> <p>Diferencia entre O(n) espacio y espacio auxiliar O(n) * Espacio total*: Toda la memoria que usa el algoritmo (entrada + salida + variables temporales). * Espacio auxiliar: Memoria extra* necesaria aparte de la entrada. *  | Caso | Entrada (<code>n</code>) | Memoria adicional | Espacio total | Espacio auxiliar | |------|---------------|------------------|---------------|------------------| | Duplicar lista | <code>n</code> | <code>n</code> | <code>O(n)</code> | <code>O(n)</code> | | Ordenar lista (copia) | <code>n</code> | <code>n</code> | <code>O(n)</code> | <code>O(n)</code> | | Ordenar in-place | <code>n</code> | constante | <code>O(n)</code> | <code>O(1)</code> |</p> <p>Conclusi\u00f3n:  - O(n) espacio: Memoria total crece proporcionalmente a <code>n</code>. - Espacio auxiliar O(n): Memoria extra (aparte de la entrada) crece proporcionalmente a <code>n</code>. - Un algoritmo puede tener espacio total O(n) pero auxiliar O(1) si modifica la entrada directamente.</p>"},{"location":"ISIS1225/#recursividad_1","title":"Recursividad","text":"<ul> <li>La funci\u00f3n se invoca a s\u00ed misma<ul> <li>Para resolver una instancia m\u00e1s peque\u00f1a del problema</li> </ul> </li> <li>Divide y vencer\u00e1s<ul> <li>Descomponer problemas en sub-problemas</li> </ul> </li> <li>Ejemplo en la vida\u00a0 real \u2192 Mu\u00f1ecas\u00a0 rusas<ul> <li>Versiones m\u00e1s peque\u00f1as anidadas</li> <li>Profundidad finita</li> </ul> </li> </ul>"},{"location":"ISIS1225/#componentes-importantes","title":"Componentes importantes","text":"<p>Componentes: - Caso base:     - Condici\u00f3n que detiene la recursi\u00f3n         - Funci\u00f3n no se invoca a s\u00ed misma - Caso recursivo:     - Funci\u00f3n se invoca a s\u00ed misma         - En una versi\u00f3n m\u00e1s peque\u00f1a del problema</p>"},{"location":"ISIS1225/#metodologia-de-desarrollo-de-software-aplicado-a-recursividad","title":"Metodolog\u00eda de Desarrollo de software aplicado a recursividad","text":"<p>[!note] An\u00e1lisis &gt; Dise\u00f1o &gt; Construcci\u00f3n &gt; Pruebas 1. An\u00e1lisis     1. Identificar y especificar el problema     2. Identificar restricciones         1. Se entiende que se debe definir las entradas y salidas de nuestra funci\u00f3n y sus respectivas restricciones.     3. Documentar         1. Note que la documentaci\u00f3n refleja las restricciones             - <code>(int)</code> indica                 - Que el tipo de dato de entrada esperado es un entero                 - Que el tipo de dato a retornar es un entero             - Se especifica la naturaleza positiva de la entrada             - El factorial es por definici\u00f3n positivo Un ejemplo</p> <pre><code>\"\"\"\nCalcula el factorial de un n\u00famero (n!).\n\n:param numero: El n\u00famero positivo para calcular su factorial.\n:type numero: int\n\n:returns: El factorial del n\u00famero proporcionado.\n:rtype: int\n\"\"\"\n</code></pre> <ol> <li>Dise\u00f1o<ol> <li>Formular ejemplos<ul> <li>Casos significativos y no redundantes</li> </ul> </li> <li>Dise\u00f1ar el algoritmo<ol> <li>Si el algoritmo es recursivo note que entonces deber\u00e1 especificar caso base y caso recursivo</li> </ol> </li> <li>Dise\u00f1ar y documentar las pruebas ejemplo se ve as\u00ed</li> </ol> </li> </ol> <pre><code>\"\"\"\nCalcula el factorial de un n\u00famero (n!).\n\n:param numero: El n\u00famero positivo para calcular su factorial.\n:type numero: int\n\n:returns: El factorial del n\u00famero proporcionado.\n:rtype: int\n\n&gt;&gt;&gt; factorial(0)  # Caso base\n1\n&gt;&gt;&gt; factorial(1)  # Caso base\n1\n&gt;&gt;&gt; factorial(2)  # Caso recursivo con 2\n2\n&gt;&gt;&gt; factorial(3)  # Caso recursivo con 3\n6\n&gt;&gt;&gt; factorial(4)  # Caso recursivo con 4\n24\n&gt;&gt;&gt; factorial(5)  # Caso recursivo con 5\n120\n\"\"\" \"\"\"\nCalcula el factorial de un n\u00famero (n!).\n\n:param numero: El n\u00famero positivo para calcular su factorial.\n:type numero: int\n\n:returns: El factorial del n\u00famero proporcionado.\n:rtype: int\n\n&gt;&gt;&gt; factorial(0)  # Caso base\n1\n&gt;&gt;&gt; factorial(1)  # Caso base\n1\n&gt;&gt;&gt; factorial(2)  # Caso recursivo con 2\n2\n&gt;&gt;&gt; factorial(3)  # Caso recursivo con 3\n6\n&gt;&gt;&gt; factorial(4)  # Caso recursivo con 4\n24\n&gt;&gt;&gt; factorial(5)  # Caso recursivo con 5\n120\n\"\"\"\n</code></pre> <ol> <li>Construcci\u00f3n <ol> <li>Codifica/implementa el dise\u00f1o usando<ol> <li>Documentaci\u00f3n</li> <li>Convenciones</li> <li>Buenas pr\u00e1cticas de programaci\u00f3n</li> </ol> </li> </ol> </li> </ol> <pre><code>def factorial(n):\n# Ahora vamos a definir los casos base primero\n    if n == 0 or n == 1:\n        return 1\n# Luego la parte recursiva\n    else:\n        return n * factorial(n - 1)\n</code></pre> <p>Sin embargo el c\u00f3digo siempre se puede pulir m\u00e1s</p> <pre><code>def factorial(n):\n    return 1 if n &lt;= 1 else n * factorial(n - 1)\n    # Esto aprovechando algo que se conoce como Operador terniario. que hace que sea muy corta la implementaci\u00f3n. Evalua una expresi\u00f3n y de concidir una condici\u00f3n hace algo, de lo contrario hace otra cosa (hace o expresi\u00f3n1 o expresi\u00f3n2)\n</code></pre> <p>Un ejemplo de operador terniario</p> <pre><code>resultado = 'Par' if num % 2 == 0 else 'Impar'\n</code></pre> <p>Note que primero se eval\u00faa la condici\u00f3n <code>num % 2 == 0</code>, luego si esta vale se eval\u00faa la expresi\u00f3n a la izquierda de evaluar <code>True</code> y de lo contrar\u00edo la que esta a la izquierda.</p> <p>A diferencia del if, este es una expresi\u00f3n</p> <p>y puede ser utilizado en asignaciones</p> <ol> <li>Finalmente debemos realizar las pruebas sobre la implementaci\u00f3n<ol> <li>Verificar si el resultado obtenido es el esperado</li> <li>Depurar<ol> <li>Corregir erroes</li> <li>Pulir/mejorar/optimizar <p>[!bug] Aqu\u00ed es super importante implementar y ejecutar los ==doctests==</p> </li> </ol> </li> </ol> </li> </ol> <pre><code>import doctest\n\ndef factorial(n):\n    \"\"\"\n    Calcula el factorial de un n\u00famero.\n\n    :param n: El n\u00famero positivo para calcular su factorial.\n    :type n: int\n\n    :returns: El factorial del n\u00famero proporcionado.\n    :rtype: int\n\n&gt;&gt;&gt; factorial(0)  # Caso base\n1\n&gt;&gt;&gt; factorial(1)  # Caso base\n1\n&gt;&gt;&gt; factorial(2)\n2\n&gt;&gt;&gt; factorial(3)\n6\n&gt;&gt;&gt; factorial(4)\n24\n&gt;&gt;&gt; factorial(5)\n120\n    \"\"\"\n    return 1 if n &lt;= 1 else n * factorial(n - 1)\n\ndoctest.run_docstring_examples(factorial, globals(), verbose=True)\n</code></pre>"},{"location":"ISIS1225/#reglas-de-recursividad","title":"Reglas de recursividad","text":"<ol> <li>Definir el(los) caso(s) base con soluci\u00f3n conocida</li> <li>Establecer el(los) caso(s) recursivo(s) que resuelvan los sub-problemas</li> <li>Garantizar que los casos recursivos converjan al caso base</li> <li>Si hay m\u00faltiples casos recursivos, deben ser disyuntos</li> <li>La soluci\u00f3n debe combinar los resultados de los casos base y recursivos</li> </ol> <p>QuizI Implementar la funci\u00f3n de fibonacci() recursivamente</p> <pre><code>fibonacci(0) = 0\nfibonacci(1) = 1\nfibonacci(2) = fibonacci(1) + fibonacci(0) = 1 + 0 = 1\nfibonacci(3) = fibonacci(2) + fibonacci(1) = 1 + 1 = 2\nfibonacci(4) = fibonacci(3) + fibonacci(2) = 2 + 1 = 3\nfibonacci(5) = fibonacci(4) + fibonacci(3) = 3 + 2 = 5\n\u2026\nfibonacci(n) = fibonacci(n\u22121) + fibonacci(n\u22122)\n</code></pre> <p>De nuevo vemos que hay dos casos bases, y podemos usar una estructura similar a la de el factorial</p> <pre><code>def fibonacci(number):\n    if number == 0:\n        return 0\n    elif number == 1:\n        return 1\n    else:\n        return fibonacci(number-1)+fibonacci(number-2)\nprint(fibonacci(4))\n</code></pre> <p>ahora esa fue la implementaci\u00f3n fea, se puede hacer mucho mejor as\u00ed </p> <pre><code>def fibonacci(n):\n    return n if n&lt;2 else fibonacci(n-1)+fibonacci(n-2)\nprint(fibonacci(24))\n</code></pre> <p>finalmente hay que incluir los docstring</p> <p>La funci\u00f3n recursiva de Fibonacci tiene complejidad temporal O(2^n), porque cada llamada genera dos llamadas adicionales, formando un \u00e1rbol de tama\u00f1o exponencial. La complejidad espacial es O(n), ya que la pila de llamadas crece hasta una profundidad m\u00e1xima de <code>n</code> antes de alcanzar el caso base.</p>"},{"location":"ISIS1225/#como-analizar-la-complejidad-de-algoritmos-recursivos","title":"Como analizar la complejidad de algoritmos recursivos","text":"<ul> <li>Contabilizar cada operaci\u00f3n realizada en cada activaci\u00f3n<ul> <li>En cada invocaci\u00f3n de la funci\u00f3n<ul> <li>Considerar s\u00f3lo las operaciones dentro de esa activaci\u00f3n</li> </ul> </li> </ul> </li> <li>Sumar el n\u00famero de operaciones ejecutadas en todas las activaciones<ul> <li>Para obtener el total del algoritmo recursivo En el caso del factorial vemos que tiene una complejidad de $O(n)$ porque cada activaci\u00f3n va a ir disminuyendo la cuenta final de a <code>n-1</code>, lo cual hace que este sea del orden <code>n</code> al finalizar.</li> </ul> </li> </ul>"},{"location":"ISIS1225/#como-analizar-la-complejidad-espacial","title":"Como analizar la complejidad espacial","text":""},{"location":"ISIS1225/#pila-stack","title":"Pila Stack","text":"<ul> <li>Estructura de datos con comportamiento LIFO<ul> <li>\u00daltimo en entrar, primero en salir (Last In, First Out)</li> </ul> </li> </ul> <p>![[Pasted image 20250811223652.png|center]]</p> <ul> <li>El Call Stack de Python es una pila<ul> <li>Almacena invocaciones a funciones y variables locales</li> </ul> </li> </ul> <p>![[Pasted image 20250811223849.png]]</p> <p>[!warning] <code>RecursionError</code> - Excepci\u00f3n que ocurre cuando:   - Una funci\u00f3n se llama a s\u00ed misma demasiadas veces - Causa:   - Recursi\u00f3n sin caso base       - Solo hay caso recursivo   - Funci\u00f3n mal dise\u00f1ada   - La ejecuci\u00f3n no alcanza el caso base - Python limita la profundidad recursiva (~1000 llamadas) - Ayuda: RecursionError</p>"},{"location":"ISIS1225/#solucionar-un-recursionerror-tenga-en-cuenta","title":"Solucionar un <code>RecursionError</code> tenga en cuenta","text":"<ul> <li> <p>Asegurar que la funci\u00f3n:</p> <ol> <li> <p>Tenga un caso base</p> </li> <li> <p>Avance hacia el o los casos base</p> <ul> <li>En cada recursi\u00f3n</li> </ul> </li> </ol> </li> <li> <p>Seg\u00fan la ubicaci\u00f3n de llamada recursiva</p> <ul> <li>==Recursividad directa==</li> <li>==Recursividad indirecta==</li> </ul> </li> <li>Seg\u00fan el n\u00famero de llamadas recursivas generadas en tiempo de ejecuci\u00f3n<ul> <li>Lineal o simple<ul> <li>Ej. factorial</li> <li>Pueden ser pasadas a iterativa</li> </ul> </li> <li>No lineal o m\u00faltiple<ul> <li>Se generan dos o m\u00e1s llamadas internas</li> <li>Ej. Funci\u00f3n Fibonacci recusiva</li> </ul> </li> </ul> </li> <li>Seg\u00fan la naturaleza de la llamada<ul> <li>No hay operaciones despu\u00e9s del llamado a la recursi\u00f3n \u00f3</li> <li>Hay operaciones pendientes despu\u00e9s de la recursi\u00f3n</li> </ul> </li> </ul>"},{"location":"ISIS1225/#clasificacion-de-funciones-recursivas-14","title":"Clasificaci\u00f3n de funciones recursivas (1/4)","text":""},{"location":"ISIS1225/#repeticion-en-python","title":"Repetici\u00f3n en Python","text":""},{"location":"ISIS1225/#iterativa-ciclos","title":"Iterativa - ciclos","text":"<ul> <li> <p>Utiliza ciclos (como <code>for</code> o <code>while</code>)</p> <ul> <li>Para repetir acciones</li> <li>Avanza mediante incrementos o decrementos expl\u00edcitos de variables</li> </ul> </li> <li> <p>Mantiene el estado del c\u00e1lculo en variables temporales</p> </li> <li> <p>Mantiene un espacio de pila constante durante su ejecuci\u00f3n</p> </li> <li>For</li> </ul> <pre><code>def factorial(n):\n    if n == 0:  # Caso especial:\n        return 1\n    else:       # Caso general:\n        fact = 1\n        for i in range(2, n + 1):\n            fact *= i\n    return fact\n</code></pre> <ul> <li>While</li> </ul>"},{"location":"ISIS1225/#recursividad_2","title":"Recursividad","text":""},{"location":"ISIS1225/#recursivo-vs-iterativo-complejidad-espacial","title":"Recursivo vs. Iterativo (complejidad espacial)","text":"<ul> <li> <p>Recursivo:</p> <ul> <li>Uso de espacio de pila de llamadas proporcional a <code>n</code></li> <li>Puede llevar a un desbordamiento de la pila para valores muy grandes de <code>n</code><ul> <li>Debido a la profundidad de la recursi\u00f3n</li> </ul> </li> <li> <p>Iterativo:</p> </li> <li> <p>Uso de espacio de pila de llamadas constante</p> </li> <li>M\u00e1s eficiente en t\u00e9rminos de memoria para valores grandes de <code>n</code></li> </ul> </li> </ul> <pre><code>\ndef contar_digitos(n):\n    return 1 if n &lt; 10 else contar_digitos(n // 10) + 1\n\nprint(contar_digitos(10))  # 2\n\n\n</code></pre>"},{"location":"ISIS1225/#colas-en-recursividad","title":"Colas en recursividad","text":"<ul> <li> <p>Recursividad final (Tail) - (Iterativa):</p> </li> <li> <p>La llamada recursiva se realiza como \u00faltima instrucci\u00f3n dentro de la funci\u00f3n</p> <ul> <li>No hay operaciones pendientes despu\u00e9s de la llamada recursiva</li> </ul> </li> <li>Puede optimizarse para volverse recursiva<ul> <li>Se puede transformar en un ciclo internamente</li> </ul> </li> <li>A este tipo de recursi\u00f3n se le suele llamar iterativa</li> <li> <p>Recursividad no final (No Tail):</p> </li> <li> <p>Hay operaciones pendientes despu\u00e9s de la llamada recursiva</p> </li> </ul>"},{"location":"ISIS1225/#w02m2-aftermath","title":"W02M2 aftermath","text":""},{"location":"ISIS1225/#w02m3","title":"W02M3","text":"<ul> <li>\u00bfQu\u00e9 es un repositorio?</li> <li>Es donde se guarda todo el c\u00f3digo fuente o todos los asets del proyecto.</li> </ul>"},{"location":"ISIS1225/#w03m2","title":"W03M2","text":""},{"location":"ISIS1225/#estructuras-de-datos-lineales-i","title":"Estructuras de datos lineales I","text":"<ul> <li>Secuencia de elementos ordenados </li> <li> <p>Con operaciones de acceso, inserci\u00f3n y eliminaci\u00f3n</p> <p>[!example] Arreglo y lista enlazada simple (Single linked list)</p> </li> <li> <p>Un ejemplo podr\u00eda ser la lista de python</p> <ul> <li>Secuencia mutable<ul> <li>Iterable e indexado<ul> <li>Desde 0</li> </ul> </li> </ul> </li> <li>Retorna su tama\u00f1o</li> <li>Strings, listas y tuplas son todas secuencias<ul> <li>Caracteres, otros tipos, solo que una es mutable y la otra no</li> </ul> </li> <li>Soportan modificaciones despues de su creaci\u00f3n</li> <li>Permite duplicado</li> <li><code>python[-2,-1,-0] # Es una lista de enteros</code></li> <li>Ahora si, bit</li> </ul> </li> </ul>"},{"location":"ISIS1225/#bit","title":"Bit","text":"<ul> <li>Unidad b\u00e1sica de informaci\u00f3n<ul> <li>Representa un 1 o un 0</li> <li>Luego esta el Byte (Que son 8 bits)<ul> <li>Agrupaci\u00f3n</li> <li>Y cada byte tiene una direcci\u00f3n de memoria \u00fanica</li> </ul> </li> </ul> </li> </ul>"},{"location":"ISIS1225/#arreglo","title":"Arreglo","text":"<ul> <li>Estructura de datos</li> <li>Almacena elementos secuenciales en memoria contigua</li> <li>Por ejemplo el string en python.</li> <li>A bajo nivel un string se almacena en el hib que tiene una segmentaci\u00f3n.<ul> <li>Note que cada caracter ocupa DOS SEGMENTOS</li> <li>Porque el character unicode necesita estos espacios.</li> <li>Eso quiere decir que por ejemplo el string <code>SAMPLE</code> ocupa 12 bytes</li> <li>Y la memoria se guarda de forma ==CONTIGUA==</li> </ul> </li> <li>Ahora los indices que nosotros manejamos no son las direcciones de memoria<ul> <li>En este caso los indices son la sumatoria de dos segmentos.</li> <li>Como todas ocupan la misma cantidad de celdas es que podemos acceder a tiempo constante a cualquier indice<ul> <li>\u00a1Esto es una maravilla!</li> </ul> </li> <li> <p>[!example] Para acceder a una celda solo tenemos que hacer <code>inicio + tama\u00f1o_celda * indice*</code>  Que en este caso es <code>2146+2*4</code>, en el caso en el que el arreglo empieza en el 2146, por el indice por 2. \u00a1Note que es por esto que empiezan en el 0! Es por esto que esta operaci\u00f3n es $O(1)$</p> </li> <li>Todo acceso es $O[1]$, adem\u00e1s el tama\u00f1o de acceso nunca es mayor a 2.</li> </ul> </li> <li>Python garantiza que todas las celdas sean del mismo tama\u00f1o<ul> <li>Si almaceno una lista de strings, entonces ya no se con antelaci\u00f3n como reservar un espacio fijo para que sea eficiente.</li> </ul> </li> </ul>"},{"location":"ISIS1225/#arreglo-compacto","title":"Arreglo compacto","text":"<ul> <li>Almacena ed forma contigua = compacta</li> <li>Por ejemplo los strings,  porque van uno despu\u00e9s del otro</li> </ul>"},{"location":"ISIS1225/#arreglo-referencial","title":"Arreglo referencial","text":"<ul> <li>Se guarda en referencias a objetos</li> <li>Una lista es un puntero que me manda a cada uno de los objetos que me interesan, algo como si tuvi\u00e9ramos una lista de cosas en obsidian que me mandan a otras p\u00e1ginas.</li> <li>\u00bf\u00d3sea se guarda el texto? NO<ul> <li>Se guardan referencias</li> </ul> </li> <li>Por esto podemos tener listas de lo que queramos, porque solo tienen que apuntar.</li> <li>Cada una de las referencias toma un espacio \u00fanico, de hecho podr\u00edan estar en un solo segmento.</li> <li>Estas tienen el beneficio de tener accesos que todav\u00eda son $O(1)$</li> </ul>"},{"location":"ISIS1225/#referencias-inmutables","title":"Referencias inmutables","text":"<p>Una lista no es m\u00e1s que una referencia apuntando a objetos 1. Tipo de dato 2. Valor  3. Identidad * Note que entonces cuando copiamos las listas, no se tienen que copiar las referencias </p> <pre><code>original = [1,2]\ncopy_1 = original[:] # copy_1 = [1,2]\ncopy_2 = original.copy() # copy_2 = [1,2]\ncopy_3 = copy.copy(original) # copy_3 = [1,2]\n</code></pre> <ul> <li> <p>Ahora los enteros son inmutables, entonces el caso donde cambien los numeros no se da</p> <p>[!question] \u00bfPorque los strings son inmutables De lo contrar\u00edo, a python le tocar\u00eda ver si en el espacio contiguo cobe lo que se esta buscando, entonces tiene que mover TODO a otra posici\u00f3n de memoria donde si quepa.</p> </li> <li> <p>Y las referencias repetidas tampoco representan gasto inecesario de memoria.</p> <p>[!example] En el caso de temp de un slicing Cuando se genera un slicing, referenciamos lo n\u00fameros de prime, pero cuando cambiamos el temp, por ejemplo con <code>temp[2]=15</code> entonces el puntero cambia a apuntar a 15 Note que: Entonces por eso es que una lista saca como objeto un string.</p> </li> </ul> <p>[!example] <code>data = [0]*8</code> Esto es un ejemplo de repetici\u00f3n de listas. En este escenario es seguro, pues el 0 no se puede cambiar. ESTO NO SE DEBE HACER CUANDO SE REFERENCIA UN MUTABLE Uno no hace esto a menos que lo haga con mutables.</p> <ul> <li>La pregunta ahora, es como hago una inicializaci\u00f3n segura.<ul> <li>...con un ciclo for... que anticlim\u00e1tico.</li> </ul> </li> </ul>"},{"location":"ISIS1225/#append-y-extend","title":"append y extend","text":"<ul> <li>append agrega una posici\u00f3n</li> <li>Y extend crea referencias para cada uno de los datos de la otra lista</li> <li>Note que estas funciones en efecto me generan la necesidad de copiar toda la lista y volver a organizar.</li> </ul>"},{"location":"ISIS1225/#arreglos-referenciales-vs-arreglos-compactos","title":"Arreglos referenciales vs Arreglos compactos","text":"<ul> <li>Los referenciales tienen un paso m\u00e1s<ul> <li>Sin embargo siguen siendo $O[1]$</li> </ul> </li> <li>La cuesti\u00f3n de referencia se basa en el espacio que ocupan cada uno, note que en los referenciales van a ocupar m\u00e1s espacio en promedio.</li> </ul>"},{"location":"ISIS1225/#complejidad-temporal-de-los-arreglos","title":"Complejidad temporal de los arreglos","text":"<ul> <li>Acceso en arreglos</li> <li>La inserci\u00f3n al inicio interno de arreglos es $O[n]$<ul> <li>As\u00ed es la vida</li> </ul> </li> <li>La eliminaci\u00f3n al inicio tmb va a ser $O[n]$<ul> <li>Los arreglos deben ser contiguos, nada que hacer.</li> </ul> </li> <li>Inserci\u00f3n al final si es $O[1]$</li> <li>Las secuencias en python tienen un tama\u00f1o fijo al crearse<ul> <li><code>tuples</code> y <code>str</code> son inmutables</li> <li>Pero las <code>list</code> si pueden cambiar de tama\u00f1o</li> <li>Python creo sin embargo un arreglo con m\u00e1s espacio, normalmente el doble.</li> <li>El problema es que cuando esto pasa, la inserci\u00f3n al final ya no es ~~$O[1]$~~, toca copiar y buscar en memoria, como copia cada cosa entonces la complejidad temporal ser\u00e1 $O[n]$, pero se llama <code>O[1] amortizado</code>.</li> <li>\u00bfPero la busqueda de espacio vacios en memor\u00eda son O[1]?<ul> <li>M\u00e1s o menos, pero se asume que si</li> </ul> </li> </ul> </li> <li>Eliminaci\u00f3n al final es $O[1]$<ul> <li>Implementa facil</li> <li>Eliminar a\u00fan m\u00e1s f\u00e1cil</li> </ul> </li> <li>Toca tener cuidado con el tama\u00f1o inicializado<ul> <li>Desplazar es costoso ![[Pasted image 20250819120354.png]]</li> </ul> </li> </ul>"},{"location":"ISIS1225/#lista-como-estructura-recursiva","title":"Lista como estructura recursiva","text":"<ul> <li>La lista vac\u00eda se entiende como el caso base</li> <li>Y luego </li> <li>[ ] Ver documentaci\u00f3n de listas en y espec\u00edficamente de array list</li> </ul>"},{"location":"ISIS1225/#ram-random-access-memories-10th-anniversary","title":"RAM [[Random Access Memories (10th Anniversary)]]","text":"<ul> <li>Esa es la maravilla del random access memory, por eso tenemos las velocidades que tenemos</li> </ul>"},{"location":"ISIS1225/#lista-enlazada-simple","title":"Lista enlazada simple","text":"<ul> <li>Single linked list</li> <li>Tiene que tener al menos una cabeza, que apunta hacia el siguiente dato, y el siguiente, hasta que se llega al final.</li> <li>De aqu\u00ed sale el concepto de cola:<ul> <li>Que es la parte final del nodo final</li> </ul> </li> <li>Note que cada nodo si guarda informaci\u00f3n</li> <li>El recorrido es navegar nodo a nodo desde la cabeza hasta la cola.<ul> <li>Y acabo en None.</li> </ul> </li> <li>Caracter\u00edsticas:<ul> <li>Operaciones comunes</li> <li>Modificable<ul> <li>Se pueden agregar nodos de forma eficiente</li> </ul> </li> <li>No indexada<ul> <li>No permite acceso directorio a un nodo por \u00edndice.</li> </ul> </li> </ul> </li> <li>Se basa en la colaboraci\u00f3n de m\u00faltiples objetos en memoria    </li> <li>Hay una instancia (objeto):<ul> <li>Representa la lista<ul> <li>Guarda referencia a la cabeza</li> </ul> </li> </ul> </li> <li>Opcional:<ul> <li>Guardar referencia a la cola:<ul> <li>Evita recorrer toda la lista</li> </ul> </li> </ul> </li> <li>Opcional:<ul> <li>Guardar contador de nodos<ul> <li>Evita recorrido total para calcular tama\u00f1o</li> </ul> </li> </ul> </li> </ul>"},{"location":"ISIS1225/#complejidades","title":"Complejidades","text":"<ol> <li>Acceso <code>O(n)</code><ol> <li>No hay indices</li> <li>Tengo que pararme en la cabeza que es lo \u00fanico que se conoce</li> </ol> </li> <li>Acceso al inicio <code>O(1)</code><ol> <li>Yo conozco la referencia inicial</li> <li>Esto es clave para escoger este tipo </li> </ol> </li> <li>Eliminaci\u00f3n al inicio <code>O(1)</code></li> <li>Inserci\u00f3n/Eliminaci\u00f3n interna <code>O(n)</code></li> <li>Inserci\u00f3n a la cola es <code>O(n)</code> a menos que tenga referencia a la cola, en ese casi si es <code>O(1)</code></li> <li>Eliminaci\u00f3n en la cola es <code>O(n)</code> aunque tenga referencia. Pues tengo que devolverme uno y apuntarlo a <code>None</code></li> </ol>"},{"location":"ISIS1225/#recap","title":"Recap","text":""},{"location":"ISIS1225/#sources","title":"Sources","text":"<ol> <li>https://eerosales24.github.io/eda_2025_20/#/</li> </ol>"}]}