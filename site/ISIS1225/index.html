
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://luigitoby.github.io/ISIS1225-notes/ISIS1225/">
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.17">
    
    
      
        <title>Home - ISIS1225 Notes</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.7e37652d.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#academy202520isis1225-uandes-class" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="ISIS1225 Notes" class="md-header__button md-logo" aria-label="ISIS1225 Notes" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            ISIS1225 Notes
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Home
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="ISIS1225 Notes" class="md-nav__button md-logo" aria-label="ISIS1225 Notes" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    ISIS1225 Notes
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  
    
  
  
    <span class="md-status md-status--active"></span>
  

  

      </a>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="academy202520isis1225-uandes-class">academy/202520/ISIS1225 #UAndes #class<a class="headerlink" href="#academy202520isis1225-uandes-class" title="Permanent link">&para;</a></h1>
<hr />
<h1 id="isis1225"><a href="https://eerosales24.github.io/eda_2025_20/#/">ISIS1225</a><a class="headerlink" href="#isis1225" title="Permanent link">&para;</a></h1>
<h2 id="cronograma">Cronograma<a class="headerlink" href="#cronograma" title="Permanent link">&para;</a></h2>
<hr />
<div class="highlight"><pre><span></span><code>not done
sort by priority
sort by tag
short mode
group by due
tags includes #academy/202520/ISIS1225   
</code></pre></div>
<h3 id="examenes">Exámenes<a class="headerlink" href="#examenes" title="Permanent link">&para;</a></h3>
<ul>
<li>[ ] #academy/202520/ISIS1225 EVA1 ⏫ 📅 2025-09-04 </li>
<li>[ ] #academy/202520/ISIS1225 EVA2 ⏫ 📅 2025-10-09 </li>
<li>[ ] #academy/202520/ISIS1225 EVA3 ⏫ 📅 2025-11-06 </li>
<li>[ ] #academy/202520/ISIS1225 EVA4 ⏫ 📅 2025-12-01 </li>
</ul>
<h3 id="retos">Retos<a class="headerlink" href="#retos" title="Permanent link">&para;</a></h3>
<ul>
<li>[ ] #academy/202520/ISIS1225 Reto1 release 📅 2025-08-19</li>
<li>[ ] #academy/202520/ISIS1225 Reto2 release 📅 2025-09-15</li>
<li>[ ] #academy/202520/ISIS1225 Reto3 release 📅 2025-10-16</li>
<li>[ ] #academy/202520/ISIS1225 Reto4 release 📅 2025-11-11</li>
<li>[ ] #academy/202520/ISIS1225 Reto1 entrega 🔼 📅 2025-09-10</li>
<li>[ ] #academy/202520/ISIS1225 Reto2 entrega🔼 📅 2025-10-15</li>
<li>[ ] #academy/202520/ISIS1225 Reto3 entrega🔼 📅 2025-11-12 </li>
<li>[ ] #academy/202520/ISIS1225 Reto4 entrega🔼 📅 2025-12-03 </li>
</ul>
<h3 id="laboratorios">Laboratorios<a class="headerlink" href="#laboratorios" title="Permanent link">&para;</a></h3>
<ul>
<li>[x] #academy/202520/ISIS1225 LAB1 release 📅 2025-08-07 ✅ 2025-08-07</li>
<li>
<p>[x] #academy/202520/ISIS1225 LAB1 entrega 📅 2025-08-15 ✅ 2025-08-14</p>
</li>
<li>
<p>[x] #academy/202520/ISIS1225 LAB2 release 📅 2025-08-14 ✅ 2025-08-14</p>
</li>
<li>
<p>[ ] #academy/202520/ISIS1225 LAB2 entrega 📅 2025-08-20</p>
</li>
<li>
<p>[ ] #academy/202520/ISIS1225 LAB3 release 📅 2025-08-21  </p>
</li>
<li>
<p>[ ] #academy/202520/ISIS1225 LAB3 entrega 📅 2025-08-27</p>
</li>
<li>
<p>[ ] #academy/202520/ISIS1225 LAB4 release 📅 2025-08-28  </p>
</li>
<li>
<p>[ ] #academy/202520/ISIS1225 LAB4 entrega 📅 2025-09-03</p>
</li>
<li>
<p>[ ] #academy/202520/ISIS1225 LAB5 parte 1 release 📅 2025-09-11  </p>
</li>
<li>
<p>[ ] #academy/202520/ISIS1225 LAB5 parte 1 entrega 📅 2025-09-17</p>
</li>
<li>
<p>[ ] #academy/202520/ISIS1225 LAB5 parte 2 release 📅 2025-09-18  </p>
</li>
<li>
<p>[ ] #academy/202520/ISIS1225 LAB5 parte 2 entrega 📅 2025-09-24</p>
</li>
<li>
<p>[ ] #academy/202520/ISIS1225 LAB6 release 📅 2025-09-25  </p>
</li>
<li>
<p>[ ] #academy/202520/ISIS1225 LAB6 entrega 📅 2025-10-01</p>
</li>
<li>
<p>[ ] #academy/202520/ISIS1225 LAB7 release 📅 2025-10-16  </p>
</li>
<li>
<p>[ ] #academy/202520/ISIS1225 LAB7 entrega 📅 2025-10-22</p>
</li>
<li>
<p>[ ] #academy/202520/ISIS1225 LAB8 release 📅 2025-10-23  </p>
</li>
<li>
<p>[ ] #academy/202520/ISIS1225 LAB8 entrega 📅 2025-10-29</p>
</li>
<li>
<p>[ ] #academy/202520/ISIS1225 LAB9 release 📅 2025-10-30  </p>
</li>
<li>
<p>[ ] #academy/202520/ISIS1225 LAB9 entrega 📅 2025-11-05</p>
</li>
<li>
<p>[ ] #academy/202520/ISIS1225 LAB10 parte 1 release 📅 2025-11-13  </p>
</li>
<li>
<p>[ ] #academy/202520/ISIS1225 LAB10 parte 1 entrega 📅 2025-11-19</p>
</li>
<li>
<p>[ ] #academy/202520/ISIS1225 LAB10 parte 2 release 📅 2025-11-20  </p>
</li>
<li>[ ] #academy/202520/ISIS1225 LAB10 parte 2 entrega 📅 2025-11-26</li>
</ul>
<h2 id="w01m1">W01M1<a class="headerlink" href="#w01m1" title="Permanent link">&para;</a></h2>
<ul>
<li>La idea del curso es organizar datos</li>
<li>Cumplir restricciones y crit. de calidad<ul>
<li>Tiempo</li>
<li>Espacio</li>
</ul>
</li>
<li>Los datos se pueden organizar en<ul>
<li>Listas</li>
<li>Pilas</li>
<li>Colas</li>
</ul>
</li>
<li>Y las estructuras son <ul>
<li>Arboles</li>
<li>Tablas (Hash)</li>
<li>Grafos</li>
</ul>
</li>
</ul>
<h3 id="arquitectura-de-aplicacion">Arquitectura de aplicación<a class="headerlink" href="#arquitectura-de-aplicacion" title="Permanent link">&para;</a></h3>
<ul>
<li>Se divide en <strong>dos</strong><ul>
<li>La ==vista==, parte necesario para que el usuario haga uso de la aplicación</li>
<li>La ==lógica==, realiza las op. sobre los datos y NO <strong>DEPENDE DE LA VISTA</strong><blockquote>
<p>[!note] La lógica es así "Vista &lt;= Lógica &lt;= Modelos &lt;= Datos"</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="uso-de-git">Uso de GIT<a class="headerlink" href="#uso-de-git" title="Permanent link">&para;</a></h3>
<ul>
<li>Tendremos tres estados<ul>
<li>modified</li>
<li>staged</li>
<li>committed</li>
</ul>
</li>
</ul>
<h3 id="algoritmos-y-complejidad">Algoritmos y complejidad<a class="headerlink" href="#algoritmos-y-complejidad" title="Permanent link">&para;</a></h3>
<p>Características:
- Precisos
- Correctos 
- Determinísticos
- Finito
Cualidades:
- General
- Eficiente
Siendo así separamos el análisis de algoritmos en dos categorías importantes, <em>temporal</em> y <strong>espacial</strong>.</p>
<h2 id="w01m2">W01M2<a class="headerlink" href="#w01m2" title="Permanent link">&para;</a></h2>
<ul>
<li>El algoritmo de busqueda binaría es un ejemplo de un algoritmo más eficiente que otro en otra tarea... ¿Pero porque?</li>
</ul>
<h3 id="tiempo-de-ejecuciion">Tiempo de ejecuciíon<a class="headerlink" href="#tiempo-de-ejecuciion" title="Permanent link">&para;</a></h3>
<ul>
<li>No todos los algoritmos vana  ser iguales, y vamos a ver que estos tienen una complejidad que involucra el espacio en memoria que ocupan y el tiempo que tardan en cumplir su tarea.</li>
<li>
<h3 id="aproximacion-a-priori">Aproximación a priorí<a class="headerlink" href="#aproximacion-a-priori" title="Permanent link">&para;</a></h3>
</li>
<li>
<p>No depende del hardware ni de la ejecución.</p>
</li>
<li>
<p>Usa y considera <strong>todos los datos</strong>.</p>
</li>
<li>
<p>Tres notaciones principales:</p>
<ul>
<li>
<p><strong>Big Theta (Θ):</strong> Crecimiento prácticamente igual en todos los casos.</p>
</li>
<li>
<p><strong>Big Omega (Ω):</strong> Crecimiento mínimo garantizado (mejor caso).</p>
</li>
<li>
<p><strong>Big O (O):</strong> Crecimiento máximo (peor caso).</p>
</li>
</ul>
</li>
</ul>
<hr />
<p><strong>7 órdenes de crecimiento temporal típicos</strong></p>
<ol>
<li>
<p><strong>O(1) – Constante:</strong></p>
<ul>
<li>
<p>Tiempo no depende del tamaño de los datos.</p>
</li>
<li>
<p>Ejemplo: <code>len(lista)</code>, comparaciones, módulo.</p>
</li>
<li>
<p>Todas las operaciones primitivas son constantes.</p>
</li>
</ul>
</li>
<li>
<p><strong>O(n) – Lineal:</strong></p>
<ul>
<li>
<p>Tiempo crece proporcionalmente con la cantidad de datos.</p>
</li>
<li>
<p>Ejemplo: recorrer una lista una vez.</p>
</li>
<li>
<p><em>Big O</em> suele considerar el <strong>peor caso</strong>.</p>
</li>
</ul>
</li>
<li>
<p><strong>O(log n) – Logarítmico:</strong></p>
<ul>
<li>
<p>Crecimiento lento del tiempo con respecto al tamaño.</p>
</li>
<li>
<p>Aparece en divisiones sucesivas y algoritmos tipo búsqueda binaria.</p>
</li>
</ul>
</li>
<li>
<p><strong>O(n log n) – Linealítmico:</strong></p>
<ul>
<li>Ejemplo típico: algoritmos de ordenamiento eficientes.</li>
</ul>
</li>
<li>
<p><strong>O(n²) – Cuadrático</strong></p>
</li>
<li>
<p><strong>O(n³) – Cúbico</strong></p>
</li>
<li>
<p><strong>O(bⁿ) – Exponencial</strong></p>
</li>
</ol>
<h2 id="w02m1">W02M1<a class="headerlink" href="#w02m1" title="Permanent link">&para;</a></h2>
<h3 id="aproximacion-empirica-a-posteriori">Aproximación (empírica a posteriori)<a class="headerlink" href="#aproximacion-empirica-a-posteriori" title="Permanent link">&para;</a></h3>
<p><strong>Ventajas</strong>
* Realista
* Sencilla
<strong>Desventajas</strong>
* Depende del entorno
    * Del hardware, S.O., programas concurrentes, etc. 
* No se puede generalizar
    * Información limitada a tamaños de entrada específicos
        * No aplica a todos los tamaños
* Influencia de factores externos
* Carga del sistema y gestión de memoria pueden distorsionar resultados.</p>
<h3 id="complejidad-espacial">Complejidad Espacial<a class="headerlink" href="#complejidad-espacial" title="Permanent link">&para;</a></h3>
<ul>
<li>Mide la memoria usada por un algoritmo en relación al tamaño de entrada</li>
<li>Generalmente basado en el peor caso de uso de memoria</li>
<li>Incluye la memoria usada por<ul>
<li>Variables </li>
<li>Asignaciones dinámicas</li>
<li>==Estructuras de datos==</li>
</ul>
</li>
</ul>
<h4 id="espacio-constante-o1">Espacio constante O(1)<a class="headerlink" href="#espacio-constante-o1" title="Permanent link">&para;</a></h4>
<ul>
<li>El espacio no depende del tamaño de la entrada
<div class="highlight"><pre><span></span><code>def suma(num1, num2):
    suma = num1 + num2
    return suma
print(suma(2,2))
</code></pre></div></li>
<li>Es idenpendiente del tamao de <code>num1</code> y <code>num2</code><ul>
<li>Solo necesita espacio constante para <code>suma</code></li>
</ul>
</li>
</ul>
<h4 id="espacio-lineal-on">Espacio lineal O(n)<a class="headerlink" href="#espacio-lineal-on" title="Permanent link">&para;</a></h4>
<ul>
<li>El espacio crece linealmente con el tamaño de la entrada
<div class="highlight"><pre><span></span><code>lista = [1,2,3]
def duplicar_lista(lista):
    lista_duplicada = []
    for elemento in lista:
        lista_duplicada.append(elemento * 2)
    return lista_duplicada
print(duplicar_lista(lista))
</code></pre></div></li>
<li>El espacio necesario para <code>lista_duplicada</code> es igual al de la lista que estamos intentando duplicar, por lo tanto <strong>crece linealmente</strong>.</li>
</ul>
<h4 id="espacio-auxiliar">Espacio auxiliar<a class="headerlink" href="#espacio-auxiliar" title="Permanent link">&para;</a></h4>
<ul>
<li>Memoria adicional aparte de la entrada
<div class="highlight"><pre><span></span><code>lista = [5,7,89,3,5]
def ordenar_lista(lista):
    lista_ordenada = sorted(lista)
    return lista_ordenada
print(ordenar_lista(lista))
</code></pre></div></li>
<li>La <code>lista_ordenada</code> es una copia de la lista<ul>
<li>Resultado en un espacio adicional<ul>
<li>Proporcional al tamaño de lista original</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>[!question] No entiendo la diferencia entre espacio lineal O(n) y el espacio auxiliar</p>
</blockquote>
<p>Diferencia entre <strong>O(n) espacio</strong> y <strong>espacio auxiliar O(n)</strong>
* <strong><em>Espacio total</em>*: Toda la memoria que usa el algoritmo (entrada + salida + variables temporales).
* </strong><em>Espacio auxiliar</em><em>: Memoria </em><em>extra</em>* necesaria aparte de la entrada.
* 
| Caso | Entrada (<code>n</code>) | Memoria adicional | Espacio total | Espacio auxiliar |
|------|---------------|------------------|---------------|------------------|
| Duplicar lista | <code>n</code> | <code>n</code> | <code>O(n)</code> | <code>O(n)</code> |
| Ordenar lista (copia) | <code>n</code> | <code>n</code> | <code>O(n)</code> | <code>O(n)</code> |
| Ordenar in-place | <code>n</code> | constante | <code>O(n)</code> | <code>O(1)</code> |</p>
<p>Conclusión: 
- <strong>O(n) espacio</strong>: Memoria total crece proporcionalmente a <code>n</code>.
- <strong>Espacio auxiliar O(n)</strong>: Memoria extra (aparte de la entrada) crece proporcionalmente a <code>n</code>.
- Un algoritmo puede tener <strong>espacio total O(n)</strong> pero <strong>auxiliar O(1)</strong> si modifica la entrada directamente.</p>
<h3 id="recursividad">Recursividad<a class="headerlink" href="#recursividad" title="Permanent link">&para;</a></h3>
<ul>
<li>La función se invoca a sí misma<ul>
<li>Resuelve instancia más pequeña que el problema general</li>
</ul>
</li>
<li>En ejemplo clásico son las muñecas rusas<ul>
<li>Versiones más pequeñas anidadas</li>
<li>Profundidad <strong>finita</strong></li>
</ul>
</li>
<li>Como en [[MATE1102]] hay dos casos<ul>
<li>Caso base<ul>
<li>Condición que detiene la recursión</li>
<li>La función no se invoca a si misma</li>
</ul>
</li>
<li>Caso recursivo<ul>
<li>Función que se invoca a sí misma</li>
<li>Es una versión ==más pequeña== del problema</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="metodologia-de-desarollo-de-sofware">Metodología de desarollo de sofware<a class="headerlink" href="#metodologia-de-desarollo-de-sofware" title="Permanent link">&para;</a></h3>
<p>Aquí el orden importa</p>
<blockquote>
<p>[!warning] Análisis &gt; Diseño &gt; Construcción &gt; Pruebas</p>
</blockquote>
<h4 id="analisis">Análisis<a class="headerlink" href="#analisis" title="Permanent link">&para;</a></h4>
<ol>
<li>Identificar y especificar el problema</li>
<li>Identificar restrucciones</li>
<li>Documentar</li>
<li>La idea es planear desde antes que es lo que se va a realizar y que tiene que hacer la función que vamos a realizar</li>
<li>Hay que entender su <strong>proposito</strong> y además que entradas y salidas vamos a esperar/diseñar</li>
<li>
<p>Finalmente también es importante pensar en las restricciones del mismo y como estas van a afectar el diseño. Estas aplican tanto para ==entrada como para salida==</p>
</li>
<li>
<p>Una vez hemos hecho e identificado el profeso arriba ya podemos escribir la documentación:</p>
</li>
</ol>
<div class="highlight"><pre><span></span><code>&quot;&quot;&quot;
Calcula el factorial de un número (n!)

param numero: El número positivo para calcular su factorial
:type numero: int

:returns: El factorial del número proporcionado
:rtype: int
&quot;&quot;&quot;
# Nota este de arriba es el formato de documentación para EDA.
</code></pre></div>
<p>Note que la documentación refleja claramente las restricciones y la naturaleza de la entrada/salida.</p>
<h4 id="diseno">Diseño<a class="headerlink" href="#diseno" title="Permanent link">&para;</a></h4>
<ol>
<li>Formular ejemplo<ol>
<li>Casos significativos y no redundantes</li>
</ol>
</li>
<li>Diseñar algoritmo</li>
<li>Diseñar y documentar las pruebas</li>
</ol>
<p><code>factorial (0) = 1
factorial (1) = 1
factorial (2) = 2
.... etc.</code></p>
<h2 id="repaso-bono-w02m1">Repaso Bono W02M1<a class="headerlink" href="#repaso-bono-w02m1" title="Permanent link">&para;</a></h2>
<p><div class="highlight"><pre><span></span><code>import matplotlib.pyplot as plt
import numpy as np

# Valores de n
n_values = np.arange(1, 20)

# Crecimientos
linear = n_values
quadratic = n_values**2
nlogn = n_values * np.log2(n_values)
exponential = 2**n_values

plt.figure(figsize=(8,5))
plt.plot(n_values, linear, label=r&quot;$n$&quot;, marker=&#39;o&#39;)
plt.plot(n_values, quadratic, label=r&quot;$n^2$&quot;, marker=&#39;o&#39;)
plt.plot(n_values, nlogn, label=r&quot;$n \log n$&quot;, marker=&#39;o&#39;)
plt.plot(n_values, exponential, label=r&quot;$2^n$&quot;, marker=&#39;o&#39;)

plt.ylim(0, 200)  # limitar para ver las curvas más pequeñas
plt.xlabel(&quot;Tamaño de entrada n&quot;)
plt.ylabel(&quot;Número de operaciones (escala lineal)&quot;)
plt.title(&quot;Comparación de órdenes de crecimiento&quot;)
plt.legend()
plt.grid(True)
plt.show()
</code></pre></div>
Aquí ves cómo crecen las funciones:</p>
<ul>
<li>
<p><strong>O(n)</strong> crece de forma lineal.</p>
</li>
<li>
<p><strong>O(n log n)</strong> crece un poco más rápido, pero sigue siendo mucho menor que cuadrática para valores grandes.</p>
</li>
<li>
<p><strong>O(n²)</strong> crece muy rápido.</p>
</li>
<li>
<p><strong>O(2ⁿ)</strong> explota enseguida, incluso con n pequeño.</p>
</li>
</ul>
<p>Esto es por lo que un algoritmo <strong>exponencial</strong> se vuelve impracticable muy rápido.</p>
<h3 id="complejidad-temporal">Complejidad temporal<a class="headerlink" href="#complejidad-temporal" title="Permanent link">&para;</a></h3>
<p><div class="highlight"><pre><span></span><code>lista = [7,6,4,3,1,5,9]
elemento_a_buscar = 5
def busqueda_secuencial(lista, elemento_a_buscar):
    resultado = None
    encontrado = False
    indice = 0 
    while indice &lt; len(lista) and not encontrado:
        if lista[indice] == elemento_a_buscar:
            resultado = lista[indice]  
            encontrado = True
        indice += 1 

    return resultado
print(busqueda_secuencial(lista, elemento_a_buscar))
</code></pre></div>
y ahora comparemoslo al algoritmo de busqueda binaría
<div class="highlight"><pre><span></span><code>lista = [1,2,3,4,5,6]
elemento_a_buscar = 5
def busqueda_binaria(lista, elemento_a_buscar):
    inicio, fin = 0, len(lista) - 1
    resultado = None
    encontrado = False
    while inicio &lt;= fin and not encontrado:
        medio = (inicio + fin)//2
        if lista[medio] &lt; elemento_a_buscar:
            inicio = medio  + 1
        elif lista[medio] &gt; elemento_a_buscar:
            inicio = medio  - 1
        else:
            resultado = lista[medio]
            encontrado = True
    return resultado
print(busqueda_binaria(lista, elemento_a_buscar))
</code></pre></div>
* Uno es mucho más rápido que el otro, pero porque exactamente....
* Partimos del método científico</p>
<blockquote>
<p>[!note] Complejidad temporal
Tiempo total de ejecución = Número de operaciones requeridas * Tiempo por operación</p>
<p>[!note] Complejidad espacial
Memoria total = Número objetos requeridos * Memoria por objeto</p>
</blockquote>
<h4 id="aproximacion-teorica-a-prori">Aproximación teórica (a prori)<a class="headerlink" href="#aproximacion-teorica-a-prori" title="Permanent link">&para;</a></h4>
<ul>
<li>Determinación aproximación matemática</li>
<li>Ventajas: No requiere la implementación del algoritmo</li>
<li>No depende del hardware o sofware de soporte<ul>
<li>Independiente del tamaño de los datos de entrada</li>
<li>Considera todos los datos de entrada</li>
</ul>
</li>
</ul>
<h4 id="notaciones-para-la-complejidad-algoritmica">Notaciones para la complejidad algoritmica<a class="headerlink" href="#notaciones-para-la-complejidad-algoritmica" title="Permanent link">&para;</a></h4>
<ol>
<li>Big Theta $\Theta$<ol>
<li>Que es la que mide exactamente como se comporta el algoritmo en terminos de tiempo vs tamaño de datos (Límite asintotico de los datos)</li>
<li>Poco usada porque es muy dificil de obtener</li>
<li>Baja aplicabilidad</li>
</ol>
</li>
<li>Big Omega $\Omega$<ol>
<li>Es básicamente el límite inferior asintótico </li>
</ol>
</li>
<li>Big O $O$<ol>
<li>Establece el límite superior asintótico</li>
<li>Se usa para describir la complejidad máxima de un algoritmo, y siempre va por arriba del estimado en la gráfica de tiempo vs tamaño de los datos.</li>
<li>Siempre estima por arriba. Es MUY INFORMATIVO.</li>
</ol>
</li>
</ol>
<h4 id="orden-constante-o1">Orden constante $O(1)$<a class="headerlink" href="#orden-constante-o1" title="Permanent link">&para;</a></h4>
<pre><code>1.  Tiempo constante y predecible
2. No aumenta con el tamaño de la entrada, osea indpendiente del tamaño de los datos
</code></pre>
<p>Ejemplos de operaciones primitivas o constantes:
![[Pasted image 20250811200137.png]]</p>
<p>Ahora un ejemplo de algoritmo de orden constante</p>
<div class="highlight"><pre><span></span><code>def es_par(n):
    &quot;&quot;&quot;
    Determina si un número es par o impar.
    Args:
        n (int): el número a verificar.
    Returns:
        bool: True si n es par, False si n es impar.
    &quot;&quot;&quot;
    return n % 2 == 0
print(es_par(5))
</code></pre></div>
<ul>
<li>Note que realmente solo se esta usando funciones que tienen ordenes constantes $O(1)$</li>
</ul>
<p>Quiz1
<div class="highlight"><pre><span></span><code>lista = [1,2,3,4,5,6]
pos = 0
def dar_elemento_en_posicion(lista, pos):
    &quot;&quot;&quot;
    Retorna el elemento en la posición especificada de la lista.

    Args:
        lista (list): La lista de la cual obtener el elemento.
        pos (int): La posición del elemento a retornar.

    Returns:
        El elemento en la posición dada o None si la posición es inválida.
    &quot;&quot;&quot;
    resultado = None
    if 0 &lt;= pos &lt; len(lista):
        resultado = lista[pos]
    return resultado
print(dar_elemento_en_posicion(lista, pos))
</code></pre></div>
Este como vemos tiene una complejidad temporal de $O(1)$ porque solo se utilizan operaciones primitivas que se repiten una unica vez. No hay ciclos y no, if no es un ciclo. Todas son comparaciones. Y recuerde ==PRINT() NO ES $O(1)$==.</p>
<h4 id="orden-lineal-on">Orden lineal $O(n)$<a class="headerlink" href="#orden-lineal-on" title="Permanent link">&para;</a></h4>
<ul>
<li>Características<ul>
<li>Tiempo crece proporcionalmente con la cantidad de datos</li>
<li>Típicamente, cada elemento se procesa una vez</li>
</ul>
</li>
<li>Ventajas<ul>
<li>Simple de entender e interpretar</li>
<li>Eficiente para volúmenes de datos pequeños o medianos</li>
</ul>
</li>
<li>Desventajas<ul>
<li>Ineficiente a gran escala
un ejemplo es:</li>
</ul>
</li>
</ul>
<p><div class="highlight"><pre><span></span><code>for elemento in lista:
    # Expresiones O(1)
</code></pre></div>
Es fácil ver como el tiempo requerido para correrlo va a crecer de manera lineal con la cantidad de datos.
<div class="highlight"><pre><span></span><code>def sumar_elementos(lista):
    &#39;&#39;&#39;
    Suma todos los elementos de una lista.

    Args:
        arreglo (list): Una lista de números (int o float).

    Returns:
        int o float: La suma de todos los elementos en la lista.
    &#39;&#39;&#39;
    total = 0
    for elemento in lista:
        total += elemento
    return total
</code></pre></div>
De nuevo es lineal porque note que las operaciones $O(1)$ se estan repitiendo n veces, las n veces corresponden a los n elementos de la lista.</p>
<div class="highlight"><pre><span></span><code>def sumar_elementos(lista):
    total = 0
    for elemento in lista:
        total += elemento
    return total
</code></pre></div>
<p>Otro ejemplo quee es lineal pues va a depender de que tantos elementos busquemos sumar, esta es una buena forma de verificar si el comportamiento que vemos es $O(1)$ o $O(n)$.</p>
<p>Y acon que haya una sola operación que se repita <code>n</code> veces es suficiente para que sea un orden lineal.
}</p>
<h4 id="analisis-de-algoritmos-por-casos">Análisis de algoritmos por casos<a class="headerlink" href="#analisis-de-algoritmos-por-casos" title="Permanent link">&para;</a></h4>
<ul>
<li>El análisis de algoritmos no constantes, típicamente considera tres casos:</li>
<li><strong>Peor caso:</strong><ul>
<li>Input que requiere el máximo tiempo de ejecución del algoritmo</li>
</ul>
</li>
<li><strong>Mejor caso:</strong><ul>
<li>Input que requiere el mínimo tiempo de ejecución del algoritmo</li>
</ul>
</li>
<li><strong>Caso promedio:</strong><ul>
<li>Estimación promedio del tiempo de ejecución<ul>
<li>Considerando la distribución probabilística del input
Por ejemplo:
<div class="highlight"><pre><span></span><code>for elemento in lista:
    if elemento == valor_buscado:
        # Valor encontrado
        # Fin de búsqueda
</code></pre></div>
En este caso, si el primer valor de la lista es el valor que buscamos vamos a obtener el mejor de los casos, osea un $O(1)$, pero lo más probable es que esto no sea verdad y que tengamos que repetir la igualdad del if por cada elemento (hay un for entonces repetimos la instrucción), esto quiere decir que vamos a terminar con un $O(n)$ en promedio y el peor de los casos no vamos a encontrar el dato pero si estamos revisando cada cosa entonces va a ser $O(n)$ también.<blockquote>
<p>[!tip] Recuerde que la notación Bif $O$ usa siempre el peor caso</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Por ejemplo en el caso de la busqueda_secuencial encontramos que en efecto se trata de que no encontraremos el dato, y en notación $O$, esto quiere decir que va a tener una complejidad $O(n)$.</p>
<h4 id="orden-logaritmico-olog-n">Orden logarítmico O(log n)<a class="headerlink" href="#orden-logaritmico-olog-n" title="Permanent link">&para;</a></h4>
<ul>
<li>Características<ul>
<li>Tiempo incrementa lentamente a medida que crecen los datos</li>
</ul>
</li>
<li>Ventajas<ul>
<li>Eficiente para grandes cantidades de datos</li>
</ul>
</li>
<li>Desventajas<ul>
<li>Mayor complejidad de implementación</li>
<li>Costos de ordenamiento y mantenimiento de datos</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>Característica clave:<ul>
<li>Reducción significativa y rápida del rango de operación</li>
</ul>
</li>
<li>Explicación:<ul>
<li>Variable se <code>i</code> divide por <code>c</code> en cada iteración<ul>
<li>Disminución hasta que <code>i &lt;= 1</code></li>
</ul>
</li>
</ul>
</li>
<li>Iteraciones limitadas a logc de <code>n</code><ul>
<li>En complejidad temporal, no importa el coeficiente constante de log<ul>
<li>Entonces, la complejidad logarítmica es <strong>O(log n)</strong>
Ejemplo:
<div class="highlight"><pre><span></span><code>i = n
while i &gt; 0:
    # Expresiones O(1)
    i /= c  # ó división entera
</code></pre></div>
<div class="highlight"><pre><span></span><code>i = 1
while i &lt; n:
    # Expresiones O(1)
    i *= c
</code></pre></div>
Son básicamente expresiones O(1), pero note que hay una división o una exponencial que me va cortando las posibilidades hasta que el algoritmo termina de correr, así básicamente aplicando la estrategia de divide y venceras.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Recordemos entonces que la ==búsqueda binaría== va a tener este tipo e complejidad temporal.</p>
<blockquote>
<p>[!tldr] Característica clave
Itera reduciendo la búsqueda a la mitad en cada paso</p>
</blockquote>
<h4 id="busqueda-secuencial-vs-busqueda-binaria-22">Búsqueda secuencial vs búsqueda binaria (2/2)<a class="headerlink" href="#busqueda-secuencial-vs-busqueda-binaria-22" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>Búsqueda secuencial:</p>
<ul>
<li><strong>Orden lineal O(n):</strong><ul>
<li>Simple pero ineficiente para grandes cantidades de datos</li>
</ul>
</li>
<li>
<p>Búsqueda binaria:</p>
</li>
<li>
<p><strong>Orden logarítmico O(log n):</strong></p>
<ul>
<li>Más complejo y requiere ordenamiento, pero,<ul>
<li>Muy eficiente para grandes cantidades de datos</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="orden-linearitmico-on-logn">Orden linearítmico O(n log(n))<a class="headerlink" href="#orden-linearitmico-on-logn" title="Permanent link">&para;</a></h4>
<ul>
<li>Características</li>
<li>Combinación de lineal y logarítmico:<ul>
<li>Tiempo crece proporcional a n y a n log n</li>
</ul>
</li>
<li>Más rápido que lineal para grandes n, pero más lento que logarítmico</li>
<li>Ventajas</li>
<li>Eficiente de moderadas a grandes volúmenes de datos</li>
<li>Desventajas</li>
<li>Mayor complejidad de implementación</li>
<li>Más lento que algoritmos logarítmicos puros</li>
<li>Puede ser muy costoso para algunos volúmenes de datos grandes
Ejemplo:
<div class="highlight"><pre><span></span><code>for i in range(1, n):  # Parte lineal
    # Expresiones O(1)
    j = 1
    while j &lt; n:  # Parte logarítmica
        # Expresiones O(1)
        j *= 2
</code></pre></div>
Otro ejemplo un poco más elaborado:
<div class="highlight"><pre><span></span><code>def buscar_en_sublistas_con_bbinaria(listas, elemento_buscado):
    &quot;&quot;&quot;
    Busca un elemento en cada sublista ordenada de la lista principal.

    Args:
        listas (list of list): Lista de sublistas ordenadas.
        elemento_buscado: el elemento a buscar.

    Returns:
        tuple: (índice_lista_principal, índice_sublista) del elemento
        encontrado, o (None, None) si el elemento no se encuentra.
    &quot;&quot;&quot;
    resultado = (None, None)
    encontrado = False

    for indice_lista_principal, sublista in enumerate(listas):
        if not encontrado:
            indice_sublista = busqueda_binaria(sublista, elemento_buscado)
            if indice_sublista is not None:
                resultado = (indice_lista_principal, indice_sublista)
                encontrado = True
    return resultado
</code></pre></div>
Note que básicamente se esta haciendo una busqueda lineal, la cual ya sabemos que tiene una complejidad temporal de O(n), y dentro de esta se esta buscando las sublistas mediante el método de busqueda binaria, que es O(log n), lo cual resulta en una complejidad espacial O(n log m)</li>
</ul>
</li>
</ul>
<h4 id="orden-cuadratico-on2">Orden cuadrático O(n2)<a class="headerlink" href="#orden-cuadratico-on2" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>Características</p>
<ul>
<li>
<p>El tiempo de ejecución escala con el cuadrado del tamaño de la entrada</p>
</li>
<li>
<p>Tiempo proporcional a n²</p>
</li>
<li>
<p>Efectivo para pequeñas entradas,</p>
<ul>
<li>Pero impráctico rápidamente con grandes volúmenes</li>
<li>Ventajas</li>
</ul>
</li>
<li>
<p>Simple de entender e interpretar</p>
</li>
<li>
<p>Eficiente para conjuntos de datos muy pequeños, con operaciones específicas</p>
</li>
</ul>
</li>
<li>
<p>Desventajas</p>
<ul>
<li>Ineficiente para grandes volúmenes de datos
Ejemplo:
<div class="highlight"><pre><span></span><code>for i in range(n):
    for j in range(n):
        # Expresiones O(1)
</code></pre></div>
El hecho de tener dos loops anidados, o dos cosas que dependen de n automáticamente lo hace $O(n^2)$</li>
</ul>
</li>
</ul>
<h4 id="complejidad-temporal-shaker-sort-13">Complejidad temporal - Shaker Sort (1/3)<a class="headerlink" href="#complejidad-temporal-shaker-sort-13" title="Permanent link">&para;</a></h4>
<p>Estime el orden de crecimiento temporal del siguiente algoritmo:</p>
<div class="highlight"><pre><span></span><code>def cocktail_shaker_sort(arr: list[int]) -&gt; None:
    start = 0
    end = len(arr) - 1
    swapped = True

    while swapped:
        swapped = False
        # Movimiento de izquierda a derecha
        for i in range(start, end):
            if arr[i] &gt; arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                swapped = True
        end -= 1

        # Movimiento de derecha a izquierda
        for i in range(end, start, -1):
            if arr[i] &lt; arr[i - 1]:
                arr[i], arr[i - 1] = arr[i - 1], arr[i]
                swapped = True
        start += 1
</code></pre></div>
<blockquote>
<p>[!warning] Ojo el Shaker sort SI ES $O(n^2)$</p>
</blockquote>
<h4 id="orden-cubico-on3">Orden cúbico O(n³)<a class="headerlink" href="#orden-cubico-on3" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>Características</p>
<ul>
<li>Tiempo de ejecución proporcional al cubo del tamaño de la entrada</li>
<li>Efectivo para pequeñas entradas<ul>
<li>Pero impráctico rápidamente con grandes volúmenes</li>
</ul>
</li>
<li>
<p>Ventajas</p>
</li>
<li>
<p>Puede ser adecuado para problemas</p>
<ul>
<li>Que requieren operaciones tridimensionales</li>
</ul>
</li>
<li>
<p>Desventajas</p>
</li>
<li>
<p>Muy ineficiente a medida que el tamaño de la entrada crece
<div class="highlight"><pre><span></span><code>for i in range(n):
    for j in range(n):
        for k in range(n):
            # Expresiones O(1)
</code></pre></div>
<div class="highlight"><pre><span></span><code>def buscar_tripletes(lista):
    &quot;&quot;&quot;
    Encuentra todos los tripletes que sumen cero.

    Args:
        lista (list): lista de números enteros.

    Returns:
        list of tuples: lista de tripletes (i, j, k), donde i + j + k == 0.
    &quot;&quot;&quot;
    triplete = []
    for i in lista: # Se ejecuta n veces
        for j in lista: # Se ejecuta n veces, por cada iteración de i
            for k in lista: # Se ejecuta n veces, por cada iteración de j
                if i + j + k == 0: # Se ejecuta n * n * n
                    triplete.append((i, j, k)) # Se ejecuta hasta n * n * n
    return triplete
</code></pre></div></p>
</li>
</ul>
<h4 id="orden-exponencial-obn">Orden exponencial O(bⁿ)<a class="headerlink" href="#orden-exponencial-obn" title="Permanent link">&para;</a></h4>
</li>
<li>
<p>Características</p>
<ul>
<li>
<p>Crecimiento muy rápido</p>
<ul>
<li>El tiempo aumenta exponencialmente con el tamaño de la entrada</li>
<li>Tiempo proporcional a <code>bⁿ</code>, donde <code>b</code> y <code>n</code> son <code>&gt; 1</code><ul>
<li>Típicamente involucra algoritmos que exploran todas las posibilidades</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Ventajas</p>
<ul>
<li>Apropiado para problemas pequeños donde se requieren soluciones exhaustivas</li>
<li>
<p>Desventajas</p>
</li>
<li>
<p>Generalmente no es viable para grandes volúmenes de datos
<div class="highlight"><pre><span></span><code>def generar_combinaciones(conjunto):
    &quot;&quot;&quot;
    Genera todas las combinaciones posibles de un conjunto.

    Args:
        conjunto: Lista que representa el conjunto (Ej.:, [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])

    Retrurns:
        list of lists: Todas las combinaciones posibles
    &quot;&quot;&quot;
    n = len(conjunto)
    total_combinaciones = 2 ** n  # Número total de combinaciones
    combinaciones = []

    for i in range(total_combinaciones):
        combinacion_actual = []
        for j in range(n):
            # Verifica si el bit j está encendido en el número i:
            if i &amp; (1 &lt;&lt; j):   
                combinacion_actual.append(conjunto[j])
        combinaciones.append(combinacion_actual)
    return combinaciones
</code></pre></div></p>
</li>
</ul>
</li>
</ul>
<h4 id="aproximacion-empirica-a-posteriori-33">Aproximación empírica (<em>a posteriori</em> ) (3/3)<a class="headerlink" href="#aproximacion-empirica-a-posteriori-33" title="Permanent link">&para;</a></h4>
<p><div class="highlight"><pre><span></span><code>import time  

start_time = time.time()  

# Your code or operation to be timed goes here  
# Example:  
sum(range(10**2))  

end_time = time.time()  
elapsed_time = end_time - start_time  

print(f&quot;Elapsed time: {elapsed_time:.4f} seconds&quot;)
</code></pre></div>
- "Realismo" </p>
<pre><code>- Mide comportamiento directo 
    - Considerando constantes y algunos factores secundarios
</code></pre>
<ul>
<li>
<p>"Sencillez" </p>
<ul>
<li>Puede  ser más fácil de implementar que algunos análisis teóricos<ul>
<li>Especialmente en algoritmos complejos</li>
</ul>
</li>
</ul>
<h3 id="complejidad-espacial_1">Complejidad Espacial<a class="headerlink" href="#complejidad-espacial_1" title="Permanent link">&para;</a></h3>
<ul>
<li>Mide la memoria usada por un algoritmo en relación al tamaño de entrada</li>
<li>Generalmente basado en el peor caso de uso de memoria</li>
<li>Incluye la memoria usada por</li>
<li>Variables </li>
<li>Asignaciones dinámicas</li>
<li>==Estructuras de datos==</li>
</ul>
<h4 id="espacio-constante-o1_1">Espacio constante O(1)<a class="headerlink" href="#espacio-constante-o1_1" title="Permanent link">&para;</a></h4>
<ul>
<li>El espacio no depende del tamaño de la entrada
<div class="highlight"><pre><span></span><code>def suma(num1, num2):
    suma = num1 + num2
    return suma
print(suma(2,2))
</code></pre></div></li>
<li>Es idenpendiente del tamao de <code>num1</code> y <code>num2</code></li>
<li>Solo necesita espacio constante para <code>suma</code></li>
</ul>
<h4 id="espacio-lineal-on_1">Espacio lineal O(n)<a class="headerlink" href="#espacio-lineal-on_1" title="Permanent link">&para;</a></h4>
<ul>
<li>El espacio crece linealmente con el tamaño de la entrada
<div class="highlight"><pre><span></span><code>lista = [1,2,3]
def duplicar_lista(lista):
    lista_duplicada = []
    for elemento in lista:
        lista_duplicada.append(elemento * 2)
    return lista_duplicada
print(duplicar_lista(lista))
</code></pre></div></li>
<li>El espacio necesario para <code>lista_duplicada</code> es igual al de la lista que estamos intentando duplicar, por lo tanto <strong>crece linealmente</strong>.</li>
</ul>
<h4 id="espacio-auxiliar_1">Espacio auxiliar<a class="headerlink" href="#espacio-auxiliar_1" title="Permanent link">&para;</a></h4>
<ul>
<li>Memoria adicional aparte de la entrada
<div class="highlight"><pre><span></span><code>lista = [5,7,89,3,5]
def ordenar_lista(lista):
    lista_ordenada = sorted(lista)
    return lista_ordenada
print(ordenar_lista(lista))
</code></pre></div></li>
<li>La <code>lista_ordenada</code> es una copia de la lista</li>
<li>Resultado en un espacio adicional<ul>
<li>Proporcional al tamaño de lista original</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>[!question] No entiendo la diferencia entre espacio lineal O(n) y el espacio auxiliar</p>
</blockquote>
<p>Diferencia entre <strong>O(n) espacio</strong> y <strong>espacio auxiliar O(n)</strong>
* <strong><em>Espacio total</em>*: Toda la memoria que usa el algoritmo (entrada + salida + variables temporales).
* </strong><em>Espacio auxiliar</em><em>: Memoria </em><em>extra</em>* necesaria aparte de la entrada.
* 
| Caso | Entrada (<code>n</code>) | Memoria adicional | Espacio total | Espacio auxiliar |
|------|---------------|------------------|---------------|------------------|
| Duplicar lista | <code>n</code> | <code>n</code> | <code>O(n)</code> | <code>O(n)</code> |
| Ordenar lista (copia) | <code>n</code> | <code>n</code> | <code>O(n)</code> | <code>O(n)</code> |
| Ordenar in-place | <code>n</code> | constante | <code>O(n)</code> | <code>O(1)</code> |</p>
<p>Conclusión: 
- <strong>O(n) espacio</strong>: Memoria total crece proporcionalmente a <code>n</code>.
- <strong>Espacio auxiliar O(n)</strong>: Memoria extra (aparte de la entrada) crece proporcionalmente a <code>n</code>.
- Un algoritmo puede tener <strong>espacio total O(n)</strong> pero <strong>auxiliar O(1)</strong> si modifica la entrada directamente.</p>
<h3 id="recursividad_1">Recursividad<a class="headerlink" href="#recursividad_1" title="Permanent link">&para;</a></h3>
<ul>
<li>La función se invoca a sí misma<ul>
<li>Para resolver una instancia más pequeña del problema</li>
</ul>
</li>
<li>Divide y vencerás<ul>
<li>Descomponer problemas en sub-problemas</li>
</ul>
</li>
<li>Ejemplo en la vida  real → Muñecas  rusas<ul>
<li>Versiones más pequeñas anidadas</li>
<li>Profundidad finita</li>
</ul>
</li>
</ul>
<h4 id="componentes-importantes">Componentes importantes<a class="headerlink" href="#componentes-importantes" title="Permanent link">&para;</a></h4>
<p>Componentes:
- <strong>Caso base</strong>:
    - Condición que detiene la recursión
        - Función <strong>no</strong> se invoca a sí misma
- <strong>Caso recursivo</strong>:
    - Función se invoca a sí misma
        - En una <strong>versión más pequeña</strong> del problema</p>
<h4 id="metodologia-de-desarrollo-de-software-aplicado-a-recursividad">Metodología de Desarrollo de software aplicado a recursividad<a class="headerlink" href="#metodologia-de-desarrollo-de-software-aplicado-a-recursividad" title="Permanent link">&para;</a></h4>
<blockquote>
<p>[!note] Análisis &gt; Diseño &gt; Construcción &gt; Pruebas
1. <strong>Análisis</strong>
    1. Identificar y especificar el problema
    2. Identificar restricciones
        1. Se entiende que se debe definir las entradas y salidas de nuestra función y sus respectivas restricciones.
    3. Documentar
        1. Note que la documentación refleja las <strong>restricciones</strong>
            - <code>(int)</code> indica
                - Que el tipo de dato de entrada esperado es un entero
                - Que el tipo de dato a retornar es un entero
            - Se especifica la naturaleza positiva de la entrada
            - El factorial es por definición positivo
Un ejemplo
<div class="highlight"><pre><span></span><code>&quot;&quot;&quot;
Calcula el factorial de un número (n!).

:param numero: El número positivo para calcular su factorial.
:type numero: int

:returns: El factorial del número proporcionado.
:rtype: int
&quot;&quot;&quot;
</code></pre></div>
2. <strong>Diseño</strong>
    1. Formular ejemplos
        - Casos significativos y no redundantes
    2. Diseñar el algoritmo
        1. Si el algoritmo es recursivo note que entonces deberá especificar <strong>caso base</strong> y <strong>caso recursivo</strong>
    3. Diseñar y documentar las pruebas
ejemplo se ve así
<div class="highlight"><pre><span></span><code>&quot;&quot;&quot;
Calcula el factorial de un número (n!).

:param numero: El número positivo para calcular su factorial.
:type numero: int

:returns: El factorial del número proporcionado.
:rtype: int

&gt;&gt;&gt; factorial(0)  # Caso base
1
&gt;&gt;&gt; factorial(1)  # Caso base
1
&gt;&gt;&gt; factorial(2)  # Caso recursivo con 2
2
&gt;&gt;&gt; factorial(3)  # Caso recursivo con 3
6
&gt;&gt;&gt; factorial(4)  # Caso recursivo con 4
24
&gt;&gt;&gt; factorial(5)  # Caso recursivo con 5
120
&quot;&quot;&quot; &quot;&quot;&quot;
Calcula el factorial de un número (n!).

:param numero: El número positivo para calcular su factorial.
:type numero: int

:returns: El factorial del número proporcionado.
:rtype: int

&gt;&gt;&gt; factorial(0)  # Caso base
1
&gt;&gt;&gt; factorial(1)  # Caso base
1
&gt;&gt;&gt; factorial(2)  # Caso recursivo con 2
2
&gt;&gt;&gt; factorial(3)  # Caso recursivo con 3
6
&gt;&gt;&gt; factorial(4)  # Caso recursivo con 4
24
&gt;&gt;&gt; factorial(5)  # Caso recursivo con 5
120
&quot;&quot;&quot;
</code></pre></div></p>
</blockquote>
<ol>
<li>Construcción <ol>
<li>Codifica/implementa el diseño usando<ol>
<li>Documentación</li>
<li>Convenciones</li>
<li>Buenas prácticas de programación
<div class="highlight"><pre><span></span><code>def factorial(n):
# Ahora vamos a definir los casos base primero
    if n == 0 or n == 1:
        return 1
# Luego la parte recursiva
    else:
        return n * factorial(n - 1)
</code></pre></div>
Sin embargo el código siempre se puede pulir más
<div class="highlight"><pre><span></span><code>def factorial(n):
    return 1 if n &lt;= 1 else n * factorial(n - 1)
    # Esto aprovechando algo que se conoce como Operador terniario. que hace que sea muy corta la implementación. Evalua una expresión y de concidir una condición hace algo, de lo contrario hace otra cosa (hace o expresión1 o expresión2)
</code></pre></div></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>Un ejemplo de operador terniario</p>
<div class="highlight"><pre><span></span><code>resultado = &#39;Par&#39; if num % 2 == 0 else &#39;Impar&#39;
</code></pre></div>
<p>Note que primero se evalúa la condición <code>num % 2 == 0</code>, luego si esta vale se evalúa la expresión a la izquierda de evaluar <code>True</code> y de lo contrarío la que esta a la izquierda.</p>
<p>A diferencia del if, <strong>este es una expresión</strong></p>
<p>y puede ser utilizado en asignaciones</p>
<ol>
<li>Finalmente debemos realizar las <strong>pruebas</strong> sobre la implementación<ol>
<li>Verificar si el resultado obtenido es el esperado</li>
<li>Depurar<ol>
<li>Corregir erroes</li>
<li>Pulir/mejorar/optimizar<blockquote>
<p>[!bug] Aquí es super importante implementar y ejecutar los ==doctests==</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<div class="highlight"><pre><span></span><code>import doctest

def factorial(n):
    &quot;&quot;&quot;
    Calcula el factorial de un número.

    :param n: El número positivo para calcular su factorial.
    :type n: int

    :returns: El factorial del número proporcionado.
    :rtype: int

&gt;&gt;&gt; factorial(0)  # Caso base
1
&gt;&gt;&gt; factorial(1)  # Caso base
1
&gt;&gt;&gt; factorial(2)
2
&gt;&gt;&gt; factorial(3)
6
&gt;&gt;&gt; factorial(4)
24
&gt;&gt;&gt; factorial(5)
120
    &quot;&quot;&quot;
    return 1 if n &lt;= 1 else n * factorial(n - 1)

doctest.run_docstring_examples(factorial, globals(), verbose=True)
</code></pre></div>
<h4 id="reglas-de-recursividad">Reglas de recursividad<a class="headerlink" href="#reglas-de-recursividad" title="Permanent link">&para;</a></h4>
<ol>
<li>Definir el(los) caso(s) base con solución conocida</li>
<li>Establecer el(los) caso(s) recursivo(s) que resuelvan los sub-problemas</li>
<li>Garantizar que los casos recursivos converjan al caso base</li>
<li>Si hay múltiples casos recursivos, deben ser disyuntos</li>
<li>La solución debe combinar los resultados de los casos base y recursivos</li>
</ol>
<p>QuizI Implementar la función de fibonacci() recursivamente</p>
<div class="highlight"><pre><span></span><code>fibonacci(0) = 0
fibonacci(1) = 1
fibonacci(2) = fibonacci(1) + fibonacci(0) = 1 + 0 = 1
fibonacci(3) = fibonacci(2) + fibonacci(1) = 1 + 1 = 2
fibonacci(4) = fibonacci(3) + fibonacci(2) = 2 + 1 = 3
fibonacci(5) = fibonacci(4) + fibonacci(3) = 3 + 2 = 5
…
fibonacci(n) = fibonacci(n−1) + fibonacci(n−2)
</code></pre></div>
<p>De nuevo vemos que hay dos casos bases, y podemos usar una estructura similar a la de el factorial</p>
<div class="highlight"><pre><span></span><code>def fibonacci(number):
    if number == 0:
        return 0
    elif number == 1:
        return 1
    else:
        return fibonacci(number-1)+fibonacci(number-2)
print(fibonacci(4))
</code></pre></div>
<p>ahora esa fue la implementación fea, se puede hacer mucho mejor así </p>
<div class="highlight"><pre><span></span><code>def fibonacci(n):
    return n if n&lt;2 else fibonacci(n-1)+fibonacci(n-2)
print(fibonacci(24))
</code></pre></div>
<p>finalmente hay que incluir los docstring</p>
<p>La función recursiva de Fibonacci tiene complejidad temporal <strong>O(2^n)</strong>, porque cada llamada genera dos llamadas adicionales, formando un árbol de tamaño exponencial.<br />
La complejidad espacial es <strong>O(n)</strong>, ya que la pila de llamadas crece hasta una profundidad máxima de <code>n</code> antes de alcanzar el caso base.</p>
<h4 id="como-analizar-la-complejidad-de-algoritmos-recursivos">Como analizar la complejidad de algoritmos recursivos<a class="headerlink" href="#como-analizar-la-complejidad-de-algoritmos-recursivos" title="Permanent link">&para;</a></h4>
<ul>
<li>Contabilizar cada operación realizada en cada activación<ul>
<li>En cada invocación de la función<ul>
<li>Considerar sólo las operaciones dentro de esa activación</li>
</ul>
</li>
</ul>
</li>
<li>Sumar el número de operaciones ejecutadas en todas las activaciones<ul>
<li>Para obtener el total del algoritmo recursivo
En el caso del factorial vemos que tiene una complejidad de $O(n)$ porque cada activación va a ir disminuyendo la cuenta final de a <code>n-1</code>, lo cual hace que este sea del orden <code>n</code> al finalizar.</li>
</ul>
</li>
</ul>
<h4 id="como-analizar-la-complejidad-espacial">Como analizar la complejidad espacial<a class="headerlink" href="#como-analizar-la-complejidad-espacial" title="Permanent link">&para;</a></h4>
<h5 id="pila-stack">Pila Stack<a class="headerlink" href="#pila-stack" title="Permanent link">&para;</a></h5>
<ul>
<li>Estructura de datos con comportamiento LIFO<ul>
<li>Último en entrar, primero en salir (Last In, First Out)</li>
</ul>
</li>
</ul>
<p>![[Pasted image 20250811223652.png|center]]</p>
<ul>
<li>El Call Stack de Python es una pila<ul>
<li>Almacena invocaciones a funciones y variables locales</li>
</ul>
</li>
</ul>
<p>![[Pasted image 20250811223849.png]]</p>
<blockquote>
<p>[!warning] <code>RecursionError</code>
- Excepción que ocurre cuando:
  - Una función se llama a sí misma demasiadas veces
- Causa:
  - Recursión sin caso base
      - Solo hay caso recursivo
  - Función mal diseñada
  - La ejecución no alcanza el caso base
- Python limita la profundidad recursiva (<strong>~1000 llamadas</strong>)
- Ayuda: <a href="https://docs.python.org/3/library/exceptions.html#RecursionError">RecursionError</a></p>
</blockquote>
<h5 id="solucionar-un-recursionerror-tenga-en-cuenta">Solucionar un <code>RecursionError</code> tenga en cuenta<a class="headerlink" href="#solucionar-un-recursionerror-tenga-en-cuenta" title="Permanent link">&para;</a></h5>
<ul>
<li>
<p>Asegurar que la función:</p>
<ol>
<li>
<p>Tenga <strong>un caso base</strong></p>
</li>
<li>
<p><strong>Avance hacia el o los casos base</strong></p>
<ul>
<li>En cada recursión</li>
</ul>
<h4 id="clasificacion-de-funciones-recursivas-14">Clasificación de funciones recursivas (1/4)<a class="headerlink" href="#clasificacion-de-funciones-recursivas-14" title="Permanent link">&para;</a></h4>
</li>
</ol>
</li>
<li>
<p>Según la ubicación de llamada recursiva</p>
<ul>
<li>==Recursividad directa==</li>
<li>==Recursividad indirecta==</li>
</ul>
</li>
<li>Según el número de llamadas recursivas generadas en tiempo de ejecución<ul>
<li>Lineal o simple<ul>
<li>Ej. factorial</li>
<li>Pueden ser pasadas a iterativa</li>
</ul>
</li>
<li>No lineal o múltiple<ul>
<li>Se generan dos o más llamadas internas</li>
<li>Ej. Función Fibonacci recusiva</li>
</ul>
</li>
</ul>
</li>
<li>Según la naturaleza de la llamada<ul>
<li>No hay operaciones después del llamado a la recursión ó</li>
<li>Hay operaciones pendientes después de la recursión</li>
</ul>
</li>
</ul>
<h3 id="repeticion-en-python">Repetición en Python<a class="headerlink" href="#repeticion-en-python" title="Permanent link">&para;</a></h3>
<h4 id="iterativa-ciclos">Iterativa - ciclos<a class="headerlink" href="#iterativa-ciclos" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>Utiliza ciclos (como <code>for</code> o <code>while</code>)</p>
<ul>
<li>Para repetir acciones</li>
<li>Avanza mediante incrementos o decrementos explícitos de variables</li>
</ul>
</li>
<li>
<p>Mantiene el estado del cálculo en variables temporales</p>
</li>
<li>
<p>Mantiene un espacio de pila <strong>constante</strong> durante su ejecución</p>
</li>
<li>For
<div class="highlight"><pre><span></span><code>def factorial(n):
    if n == 0:  # Caso especial:
        return 1
    else:       # Caso general:
        fact = 1
        for i in range(2, n + 1):
            fact *= i
    return fact
</code></pre></div></li>
<li>While</li>
</ul>
<h4 id="recursividad_2">Recursividad<a class="headerlink" href="#recursividad_2" title="Permanent link">&para;</a></h4>
<h5 id="recursivo-vs-iterativo-complejidad-espacial">Recursivo vs. Iterativo (complejidad espacial)<a class="headerlink" href="#recursivo-vs-iterativo-complejidad-espacial" title="Permanent link">&para;</a></h5>
<ul>
<li>
<p><strong>Recursivo</strong>:</p>
<ul>
<li>Uso de espacio de pila de llamadas proporcional a <code>n</code></li>
<li>Puede llevar a un desbordamiento de la pila para valores muy grandes de <code>n</code><ul>
<li>Debido a la profundidad de la recursión</li>
</ul>
</li>
<li>
<p><strong>Iterativo</strong>:</p>
</li>
<li>
<p>Uso de espacio de pila de llamadas constante</p>
</li>
<li>Más eficiente en términos de memoria para valores grandes de <code>n</code></li>
</ul>
<h5 id="colas-en-recursividad">Colas en recursividad<a class="headerlink" href="#colas-en-recursividad" title="Permanent link">&para;</a></h5>
<ul>
<li>
<p><strong>Recursividad final (Tail) - (Iterativa)</strong>:</p>
</li>
<li>
<p>La llamada recursiva se realiza como última instrucción dentro de la función</p>
<ul>
<li>No hay operaciones pendientes después de la llamada recursiva</li>
</ul>
</li>
<li>Puede optimizarse para volverse recursiva<ul>
<li>Se puede transformar en un ciclo internamente</li>
</ul>
</li>
<li>A este tipo de recursión se le suele llamar iterativa</li>
<li>
<p><strong>Recursividad no final (No Tail)</strong>:</p>
</li>
<li>
<p>Hay operaciones pendientes después de la llamada recursiva</p>
</li>
</ul>
<h2 id="w02m2-aftermath">W02M2 aftermath<a class="headerlink" href="#w02m2-aftermath" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code>def contar_digitos(n):
    return 1 if n &lt; 10 else contar_digitos(n // 10) + 1

print(contar_digitos(10))  # 2
</code></pre></div>
<h2 id="w02m3">W02M3<a class="headerlink" href="#w02m3" title="Permanent link">&para;</a></h2>
<ul>
<li>¿Qué es un repositorio?</li>
<li>Es donde se guarda todo el código fuente o todos los asets del proyecto.</li>
</ul>
<h2 id="w03m2">W03M2<a class="headerlink" href="#w03m2" title="Permanent link">&para;</a></h2>
<h3 id="estructuras-de-datos-lineales-i">Estructuras de datos lineales I<a class="headerlink" href="#estructuras-de-datos-lineales-i" title="Permanent link">&para;</a></h3>
<ul>
<li>Secuencia de elementos ordenados </li>
<li>Con operaciones de acceso, inserción y eliminación<blockquote>
<p>[!example] Arreglo y lista enlazada simple (Single linked list)</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>Un ejemplo podría ser la lista de python</p>
<ul>
<li>Secuencia mutable<ul>
<li>Iterable e indexado<ul>
<li>Desde 0</li>
</ul>
</li>
</ul>
</li>
<li>Retorna su tamaño</li>
<li>Strings, listas y tuplas son todas secuencias<ul>
<li>Caracteres, otros tipos, solo que una es mutable y la otra no</li>
</ul>
</li>
<li>Soportan modificaciones despues de su creación</li>
<li>Permite <strong>duplicado</strong></li>
<li><code>python[-2,-1,-0] # Es una lista de enteros</code></li>
<li>Ahora si, bit</li>
</ul>
</li>
</ul>
<h3 id="bit">Bit<a class="headerlink" href="#bit" title="Permanent link">&para;</a></h3>
<ul>
<li>Unidad básica de información<ul>
<li>Representa un 1 o un 0</li>
<li>Luego esta el <strong>Byte</strong> (Que son 8 bits)<ul>
<li>Agrupación</li>
<li>Y cada byte tiene una dirección de memoria única</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="arreglo">Arreglo<a class="headerlink" href="#arreglo" title="Permanent link">&para;</a></h3>
<ul>
<li>Estructura de datos</li>
<li>Almacena elementos secuenciales en memoria contigua</li>
<li>Por ejemplo el string en python.</li>
<li>A bajo nivel un string se almacena en el hib que tiene una segmentación.<ul>
<li>Note que cada caracter ocupa <strong>DOS SEGMENTOS</strong></li>
<li>Porque el character unicode necesita estos espacios.</li>
<li>Eso quiere decir que por ejemplo el string <code>SAMPLE</code> ocupa 12 bytes</li>
<li>Y la memoria se guarda de forma ==CONTIGUA==</li>
</ul>
</li>
<li>Ahora los indices que nosotros manejamos no son las direcciones de memoria<ul>
<li>En este caso los indices son la sumatoria de dos segmentos.</li>
<li>Como todas ocupan la misma cantidad de celdas es que podemos acceder a <strong>tiempo constante a cualquier indice</strong><ul>
<li>¡Esto es una maravilla!</li>
</ul>
</li>
<li>
<blockquote>
<p>[!example] Para acceder a una celda solo tenemos que hacer <code>inicio + tamaño_celda * indice*</code> 
Que en este caso es <code>2146+2*4</code>, en el caso en el que el arreglo empieza en el 2146, por el indice por 2. ¡Note que es por esto que empiezan en el 0!
Es por esto que esta operación es $O(1)$</p>
</blockquote>
</li>
<li>Todo acceso es $O[1]$, además el tamaño de acceso nunca es mayor a 2.</li>
</ul>
</li>
<li>Python garantiza que todas las celdas sean del mismo tamaño<ul>
<li>Si almaceno una lista de strings, entonces ya no se con antelación como reservar un espacio fijo para que <strong>sea eficiente</strong>.</li>
</ul>
</li>
</ul>
<h4 id="arreglo-compacto">Arreglo compacto<a class="headerlink" href="#arreglo-compacto" title="Permanent link">&para;</a></h4>
<ul>
<li>Almacena ed forma contigua = compacta</li>
<li>Por ejemplo los strings,  porque van uno después del otro</li>
</ul>
<h4 id="arreglo-referencial">Arreglo referencial<a class="headerlink" href="#arreglo-referencial" title="Permanent link">&para;</a></h4>
<ul>
<li>Se guarda en referencias a objetos</li>
<li>Una lista es un puntero que me manda a cada uno de los objetos que me interesan, algo como si tuviéramos una lista de cosas en obsidian que me mandan a otras páginas.</li>
<li>¿Ósea se guarda el texto? <strong>NO</strong><ul>
<li>Se guardan referencias</li>
</ul>
</li>
<li>Por esto podemos tener listas de lo que queramos, porque solo tienen que apuntar.</li>
<li>Cada una de las referencias toma un espacio único, de hecho podrían estar en un solo segmento.</li>
<li>Estas tienen el beneficio de tener accesos que todavía son $O(1)$</li>
</ul>
<h5 id="referencias-inmutables">Referencias inmutables<a class="headerlink" href="#referencias-inmutables" title="Permanent link">&para;</a></h5>
<p><strong>Una lista no es más que una referencia apuntando a objetos</strong>
1. Tipo de dato
2. Valor 
3. Identidad
* Note que entonces cuando copiamos las listas, no se tienen que copiar las referencias 
<div class="highlight"><pre><span></span><code>original = [1,2]
copy_1 = original[:] # copy_1 = [1,2]
copy_2 = original.copy() # copy_2 = [1,2]
copy_3 = copy.copy(original) # copy_3 = [1,2]
</code></pre></div>
* Ahora los enteros son inmutables, entonces el caso donde cambien los numeros no se da</p>
<blockquote>
<p>[!question] ¿Porque los strings son inmutables
De lo contrarío, a python le tocaría ver si en el espacio contiguo cobe lo que se esta buscando, entonces tiene que mover TODO a otra posición de memoria donde si quepa.</p>
</blockquote>
<ul>
<li>Y las referencias repetidas tampoco representan gasto inecesario de memoria.<blockquote>
<p>[!example] En el caso de temp de un slicing
Cuando se genera un slicing, referenciamos lo números de prime, pero cuando cambiamos el temp, por ejemplo con <code>temp[2]=15</code> entonces el <strong>puntero</strong> cambia a apuntar a 15
<strong>Note que:</strong> Entonces por eso es que una lista saca como objeto un string.</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>[!example] <code>data = [0]*8</code>
Esto es un ejemplo de repetición de listas.
En este escenario es seguro, pues el 0 no se puede cambiar. <strong>ESTO NO SE DEBE HACER CUANDO SE REFERENCIA UN MUTABLE</strong>
Uno no hace esto a menos que lo haga con mutables.</p>
</blockquote>
<ul>
<li>La pregunta ahora, es como hago una inicialización segura.<ul>
<li>...con un ciclo for... que anticlimático.</li>
</ul>
</li>
</ul>
<h5 id="append-y-extend">append y extend<a class="headerlink" href="#append-y-extend" title="Permanent link">&para;</a></h5>
<ul>
<li>append agrega una posición</li>
<li>Y extend crea referencias para cada uno de los datos de la otra lista</li>
<li>Note que estas funciones en efecto me generan la necesidad de copiar toda la lista y volver a organizar.</li>
</ul>
<h4 id="arreglos-referenciales-vs-arreglos-compactos">Arreglos referenciales vs Arreglos compactos<a class="headerlink" href="#arreglos-referenciales-vs-arreglos-compactos" title="Permanent link">&para;</a></h4>
<ul>
<li>Los referenciales tienen un paso más<ul>
<li>Sin embargo siguen siendo $O[1]$</li>
</ul>
</li>
<li>La cuestión de referencia se basa en el espacio que ocupan cada uno, note que en los referenciales van a ocupar más espacio en promedio.</li>
</ul>
<h3 id="complejidad-temporal-de-los-arreglos">Complejidad temporal de los arreglos<a class="headerlink" href="#complejidad-temporal-de-los-arreglos" title="Permanent link">&para;</a></h3>
<ul>
<li>Acceso en arreglos</li>
<li>La inserción al inicio interno de arreglos es $O[n]$<ul>
<li>Así es la vida</li>
</ul>
</li>
<li>La eliminación al inicio tmb va a ser $O[n]$<ul>
<li>Los arreglos deben ser contiguos, nada que hacer.</li>
</ul>
</li>
<li>Inserción al final si es $O[1]$</li>
<li>Las secuencias en python tienen un tamaño fijo al crearse<ul>
<li><code>tuples</code> y <code>str</code> son inmutables</li>
<li>Pero las <code>list</code> si pueden cambiar de tamaño</li>
<li>Python creo sin embargo un arreglo con más espacio, normalmente el doble.</li>
<li>El problema es que cuando esto pasa, la inserción al final ya no es ~~$O[1]$~~, toca copiar y buscar en memoria, como copia cada cosa entonces la complejidad temporal será $O[n]$, pero se llama <code>O[1] amortizado</code>.</li>
<li>¿Pero la busqueda de espacio vacios en memoría son O[1]?<ul>
<li>Más o menos, pero se asume que si</li>
</ul>
</li>
</ul>
</li>
<li>Eliminación al final es $O[1]$<ul>
<li>Implementa facil</li>
<li>Eliminar aún más fácil</li>
</ul>
</li>
<li>Toca tener cuidado con el tamaño inicializado<ul>
<li>Desplazar es costoso
![[Pasted image 20250819120354.png]]</li>
</ul>
</li>
</ul>
<h3 id="lista-como-estructura-recursiva">Lista como estructura recursiva<a class="headerlink" href="#lista-como-estructura-recursiva" title="Permanent link">&para;</a></h3>
<ul>
<li>La lista vacía se entiende como el caso base</li>
<li>Y luego </li>
<li>[ ] Ver documentación de listas en y específicamente de array list</li>
</ul>
<h3 id="ram-random-access-memories-10th-anniversary">RAM [[Random Access Memories (10th Anniversary)]]<a class="headerlink" href="#ram-random-access-memories-10th-anniversary" title="Permanent link">&para;</a></h3>
<ul>
<li>Esa es la maravilla del random access memory, por eso tenemos las velocidades que tenemos</li>
</ul>
<h3 id="lista-enlazada-simple">Lista enlazada simple<a class="headerlink" href="#lista-enlazada-simple" title="Permanent link">&para;</a></h3>
<ul>
<li>Single linked list</li>
<li>Tiene que tener al menos una cabeza, que apunta hacia el siguiente dato, y el siguiente, hasta que se llega al final.</li>
<li>De aquí sale el concepto de cola:<ul>
<li>Que es la parte final del nodo final</li>
</ul>
</li>
<li>Note que cada nodo si guarda información</li>
<li>El recorrido es navegar nodo a nodo desde la cabeza hasta la cola.<ul>
<li>Y acabo en None.</li>
</ul>
</li>
<li><strong>Características:</strong><ul>
<li>Operaciones comunes</li>
<li>Modificable<ul>
<li>Se pueden agregar nodos de forma eficiente</li>
</ul>
</li>
<li>No indexada<ul>
<li>No permite acceso directorio a un nodo por índice.</li>
</ul>
</li>
</ul>
</li>
<li>Se basa en la colaboración de múltiples objetos en memoria    </li>
<li>Hay una instancia (objeto):<ul>
<li>Representa la lista<ul>
<li>Guarda referencia a la cabeza</li>
</ul>
</li>
</ul>
</li>
<li>Opcional:<ul>
<li>Guardar referencia a la cola:<ul>
<li>Evita recorrer toda la lista</li>
</ul>
</li>
</ul>
</li>
<li>Opcional:<ul>
<li>Guardar contador de nodos<ul>
<li>Evita recorrido total para calcular tamaño</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="complejidades">Complejidades<a class="headerlink" href="#complejidades" title="Permanent link">&para;</a></h4>
<ol>
<li>Acceso <code>O(n)</code><ol>
<li>No hay indices</li>
<li>Tengo que pararme en la cabeza que es lo único que se conoce</li>
</ol>
</li>
<li>Acceso al inicio <code>O(1)</code><ol>
<li>Yo conozco la referencia inicial</li>
<li>Esto es clave para escoger este tipo </li>
</ol>
</li>
<li>Eliminación al inicio <code>O(1)</code></li>
<li>Inserción/Eliminación interna <code>O(n)</code></li>
<li>Inserción a la cola es <code>O(n)</code> a menos que tenga referencia a la cola, en ese casi si es <code>O(1)</code></li>
<li>Eliminación en la cola es <code>O(n)</code> aunque tenga referencia. Pues tengo que devolverme uno y apuntarlo a <code>None</code></li>
</ol>
<h1 id="recap">Recap<a class="headerlink" href="#recap" title="Permanent link">&para;</a></h1>
<h1 id="sources">Sources<a class="headerlink" href="#sources" title="Permanent link">&para;</a></h1>
<ol>
<li>https://eerosales24.github.io/eda_2025_20/#/</li>
</ol>
<hr />







  
  






                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.92b07e13.min.js"></script>
      
    
  </body>
</html>